<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8"/>
  <title>
    Node.js for Administrators
  </title>
  <link href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/github.min.css" rel="stylesheet"/>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/highlight.min.js">
  </script>
  <script>
   hljs.initHighlightingOnLoad();
  </script>
  <style type="text/css">
   body {
 font-size:11pt;
 font-family:arial;
 line-height:15pt;
}

code {
 font-family:monospace;
 font-size:10pt;
 line-height:14pt;
 border:1px solid gray;
 padding:3px;
 margin: 3px;
}
  </style>
 </head>
 <body>
  <h1>
   Node.js for Administrators
  </h1>
  <p>
   Welcome to the Node.js for Administrators Course. This course will teach you many of the essentials for administrating and developing with Node.js. The course can be taken with any recent version of Node.js on any platform (Windows, Max OS X, Linux, SunOS) and any supported processor architecture (32-bit or 64-bit). To complete many of the exercises, the reader will need root privileges on their computer if they are using Mac OS X or Linux.  The course begins with a review of conventions used in this document then proceeds to the administration and software development content about Node.js.
  </p>
  <h2>
   Document Conventions
  </h2>
  <p>
   To help the reader, this document follows several conventions.
  </p>
  <p>
   Node.js runs on a variety of platforms.  On each platform, the command prompt or terminal is called by different names.  For the sake of simplicity, when referring to the command prompt or terminal, the term
   <strong>
    terminal
   </strong>
   will be used.
  </p>
  <p>
   For commands that should be executed from the platform's terminal, a
   <strong>
    $
   </strong>
   is used.
  </p>
  <pre><code class="bash">$ &lt;enter some command here and press enter&gt;
</code></pre>
  <p>
   For multiple commands, the following convention is used.
  </p>
  <pre><code>$ &lt;enter the first command here and press enter&gt;

$ &lt;enter the second command here and press enter&gt;
</code></pre>
  <p>
   Observe how each terminal command begins with a
   <strong>
    $
   </strong>
   . After typing the command, you will press enter to execute the command.  The
   <strong>
    $
   </strong>
   represents a generic terminal prompt. The terminal prompt on your computer will most likely be different.
  </p>
  <p>
   When entering commands into the Node.js interactive shell, the commands will be formatted as follows.
  </p>
  <pre><code class="bash">&gt; &lt;enter some Node.js interactive shell command here and press enter&gt;
</code></pre>
  <p>
   Observe how each Node.js interactive shell commands being with
   <strong>
    &gt;
   </strong>
   . The character
   <strong>
    &gt;
   </strong>
   is the default Node.js interactive shell command prompt.
  </p>
  <p>
   Finally, when programming code should be typed in a text editor (any text editor can be used, but we recommend the cross-platform, JavaScript based
   <a href="http://www.atom.io">
    Atom editor
   </a>
   ), the code will be represented as follows.
  </p>
  <pre><code class="javascript">console.log("Hello World!");
</code></pre>
  <p>
   Observe how there is no
   <strong>
    $
   </strong>
   and no
   <strong>
    &gt;
   </strong>
   at the beginning of the line.  Programming code will have no prompt.  Unless otherwise stated, all programming code will be written in JavaScript.
  </p>
  <h2>
   Overview of Node.js
  </h2>
  <p>
   Traditionally, JavaScript has been limited to the web browser.  With the advent of Node.js, JavaScript can run on any platform that supports Google's V8 JavaScript engine.  Such platforms include Microsoft Windows, Mac OS X, SunOS and the many flavors of Linux.  Google's V8 JavaScript engine was written for its Chrome Web Browser, but Node.js does not run within a web browser.  This allows JavaScript to be written and executed on any platform that supports Google's V8 engine even if Chrome does not run on it.  One huge advantage to running outside of the web browser is that Node.js is not subject to the same security limitations that constrains JavaScript in the web browser.  Node.js applications can access the file system, interact with the networking system of the computer and perform many additional tasks similar to any other programming language such as C++, C# or Java.
  </p>
  <p>
   Even with the increased capabilities of JavaScript through Node.js, fundamental principles such as single-threaded operation, the JavaScript event loop, etc... all apply in Node.js because Node.js is still running JavaScript and as such the underlying design and architectural principles of JavaScript very much apply.
  </p>
  <p>
   JavaScript is single-threaded; therefore, it does not support true concurrency.  Efficiently written JavaScript appears to be concurrent through the use of an event loop.  At it's core, JavaScript is event driven.  An event occurs, a task is pushed on to the event queue, the tasks are executed in order and upon completion the next task on the queue is executed.
  </p>
  <p>
   The JavaScript event loop executes tasks in order using a run-to-completion model.  Once JavaScript begins the execution of a task, it does nothing else until the task has been completed, then JavaScript processes the next task.  To improve JavaScript performance, developers should write their code such that each task is as quick as possible, so that the JavaScript engine can process the next task as quickly as possible.  A good rule of thumb is that each task should execute in under 100ms.
  </p>
  <p>
   To minimize the amount of time each task takes, all API calls from within Node.js, especially I/O operations, are asynchronous (in many cases synchronous versions of methods are available but should only be used during the application's start up phase before it begins to perform its primary purpose).  While the application's JavaScript code is single-threaded, the Node.js internals that handle API calls do so by using multiple threads and other traditional concurrent programming features of the underlying operating system.  Nevertheless, the results of these asynchronous operations are handled via callback functions that are pushed on to the JavaScript event loop upon completion of the API call. To sum it up, its commonly said, "Everything in Node.js runs in parallel; except, your code".
  </p>
  <p>
   While JavaScript is single-threaded, and only one Node.js process can run on a given processor/core, Node.js itself can run one copy of itself on each processor/core (also known as CPUs within Node.js's process API).  Using a Node.js module like cluster, multiple Node.js processes running on different CPUs can be coordinated and provide increased throughput and reliability to processing client requests.
  </p>
  <h2>
   Node.js Installation
  </h2>
  <p>
   Installing Node.js is a relatively simple task.  For Windows and Mac OS X users, installer applications are available directly from the
   <a href="http://www.nodejs.org">
    Node.js web site
   </a>
   .  For computers running Windows, Mac OS X, SunOS and Linux pre-compiled binaries are available.  For users who desire to build a fresh copy of Node.js, the Node.js source code is available for download from the Node.js web site.  Finally, for Linux computers running distros that are either RPM based of Debian based, Node.js can be installed with their respective package managers.
  </p>
  <h3>
   Installer Applications
  </h3>
  <p>
   Installing on Windows and Mac OS X is as easy as running the binary installer available on the Node.js web site at
   <a href="http://nodejs.org/">
   </a>
   <a href="http://nodejs.org/">
    http://nodejs.org/
   </a>
   .
  </p>
  <h3>
   Linux Package Managers
  </h3>
  <p>
   To install Node.js on Linux, there are three options: Linux packages, pre-compiled binaries, and local source code compilation.  Linux packages are available from
   <a href="http://nodesource.com">
    nodesource.com
   </a>
   .  Below are the instructions for installing Node.js packages on Debian based (Ubuntu) and Red Hat based (Fedora, CentOS) Linux distros.
  </p>
  <p>
   Debian based Linux Distros
  </p>
  <pre><code class="bash">$ curl -sL https://deb.nodesource.com/setup | bash -

$ sudo apt-get install -y nodejs
</code></pre>
  <p>
   RPM based Linux Distros
  </p>
  <pre><code class="bash">$ curl -sL https://rpm.nodesource.com/setup | bash -

$ sudo yum install -y nodejs
</code></pre>
  <p>
   The latest versions of Ubuntu (Debian-based) and CentOS (RPM-based) contain Node.js and the Node Package Manager in their package repositories.  Unfortunately, these versions are not usually the latest versions of Node.js.  Its better to use the
   <a href="http://**nodesource.com">
    **nodesource.com
   </a>
   <strong>
    repositories above.  If you choose to install Node.js and the NPM package manager from the standard Debian or RPM repositories, the package ids for both Linux Package Management systems are
   </strong>
   nodejs
   <strong>
    and
   </strong>
   npm
   <strong>
    .  When installing with the
    <a href="http://**nodesource.com">
     **nodesource.com
    </a>
   </strong>
   repositories, both Node.js and NPM and installed via the
   <strong>
    nodejs
   </strong>
   package.
  </p>
  <h3>
   Pre-Compiled Binaries
  </h3>
  <p>
   Pre-compiled binaries are available for all four platforms (Windows, OS X, Linux, SunOS) and come in 32-bit and 64-bit architecture varieties.  To download a pre-compiled binary, navigate to the URL
   <a href="http://nodejs.org/download/">
   </a>
   <a href="http://nodejs.org/download/">
    http://nodejs.org/download/
   </a>
   .
  </p>
  <h4>
   Windows
  </h4>
  <p>
   To use the pre-compiled binary for Windows, download the
   <strong>
    exe
   </strong>
   file appropriate for the computer's architecture (32-bit or 64-bit) and execute it.  A Node.js REPL terminal will appear and JavaScript can be executed.  The pre-compiled binary for Windows does not come with the Node Package Manager.
  </p>
  <h4>
   OS X, Linux &amp; SunOS
  </h4>
  <p>
   To use the pre-compiled binaries for Mac OS X, SunOS and Linux, download the appropriate gzipped tarball for your computer's platform and architecture and complete the following steps.
  </p>
  <p>
   To download the pre-compiled binaries for Node.js from the command line execute one of the two following commands (replacing the URL with the URL appropriate for your computer's platform and architecture.
  </p>
  <pre><code class="bash">$ wget http://nodejs.org/dist/v0.10.35/node-v0.10.35-linux-x64.tar.gz
</code></pre>
  <p>
   or
  </p>
  <pre><code class="bash">$ curl -O http://nodejs.org/dist/v0.10.35/node-v0.10.35-linux-x64.tar.gz
</code></pre>
  <p>
   Both commands download the gzipped tarball to the current folder; therefore, only execute one of them.
  </p>
  <p>
   The next step is to unzip and unarchive the gzipped tarball.  Be sure to replace the filename listed in the example below with the name of the file you downloaded.
  </p>
  <pre><code class="bash">$ gzip -d node-v0.10.35-linux-x64.tar.gz

$ tar -xf node-v0.10.35-linux-x64.tar.gz
</code></pre>
  <p>
   The
   <strong>
    -d
   </strong>
   option tells
   <strong>
    gzip
   </strong>
   to decompress the file.  The
   <strong>
    -x
   </strong>
   option tells
   <strong>
    tar
   </strong>
   to extract the archive.  The
   <strong>
    -f
   </strong>
   option tell
   <strong>
    tar
   </strong>
   the archive is a file (as opposed to a tape drive or something else).
  </p>
  <p>
   Or, you perform the unzip and unarchive with one command.
  </p>
  <pre><code class="bash">$ tar -zxf node-v0.10.35-linux-x64.tar.gz
</code></pre>
  <p>
   The
   <strong>
    -z
   </strong>
   option tells
   <strong>
    tar
   </strong>
   to unzip the file before extracting the archive.
  </p>
  <p>
   The next step is to copy the Node.js files to the desired location on your computer, and setting up symbolic links so that all users can run it from the command line.  There are many ways to deploy the files, the key is to setup the symbolic links correctly.  A typical location to copy the node files to is the
   <strong>
    /usr/local
   </strong>
   folder.  To copy the files, type the following command with root privileges in a terminal window.
  </p>
  <pre><code class="bash">$ sudo mv node-v0.10.35-linux-x64 /usr/local
</code></pre>
  <p>
   After moving the files, two symbolic links need to be created.
  </p>
  <pre><code class="bash">$ ln -s /usr/local/node-v0.10.35-linux-x64/bin/node /usr/local/bin/node

$ ln -s /usr/local/node-v0.10.35-linux-x64/bin/npm /usr/local/bin/npm
</code></pre>
  <p>
   After the symbolic links have been created, Node.js is ready to be used.
  </p>
  <h3>
   Compiling the Source Locally
  </h3>
  <p>
   If you require a customized build of Node.js or your platform architecture is not supported then you can download the Node.js source code and create a customized build of Node.js.  The following instructions are for Linux-based systems only.  To compile Node.js on Microsoft Windows or Mac OS X requires Microsoft Visual Studio Express or XCode, respectively.
  </p>
  <p>
   To download the Node.js source code from a terminal, execute one of the following two commands below.  Be sure to modify the version number to reflect the version you are intending to download.
  </p>
  <pre><code class="bash">$ wget http://nodejs.org/dist/v0.10.35/node-v0.10.35.tar.gz
</code></pre>
  <p>
   or
  </p>
  <pre><code class="bash">$ curl -O http://nodejs.org/dist/v0.10.35/node-v0.10.35.tar.gz
</code></pre>
  <p>
   Both commands download the gzipped tarball to the current folder; therefore, only execute one of them.
  </p>
  <p>
   The next step is to unzip and unarchive the gzipped tarball.  Be sure to replace the version number listed in the example below with the version number of the file you downloaded.
  </p>
  <pre><code class="bash">$ gzip -d node-v0.10.35.tar.gz

$ tar -xf node-v0.10.35.tar.gz
</code></pre>
  <p>
   The
   <strong>
    -d
   </strong>
   option tells
   <strong>
    gzip
   </strong>
   to decompress the file.  The
   <strong>
    -x
   </strong>
   option tells
   <strong>
    tar
   </strong>
   to extract the archive.  The
   <strong>
    -f
   </strong>
   option tell
   <strong>
    tar
   </strong>
   the archive is a file (as opposed to a tape drive or something else).
  </p>
  <p>
   Or, you perform the unzip and unarchive with one command.
  </p>
  <pre><code class="bash">$ tar -zxf node-v0.10.35.tar.gz
</code></pre>
  <p>
   The
   <strong>
    -z
   </strong>
   option tells
   <strong>
    tar
   </strong>
   to unzip the file before extracting the archive.
  </p>
  <p>
   Change to the folder containing the source code and type the following command.
   <strong>
    DO NOT RUN
   </strong>
   this command with root privileges.
  </p>
  <pre><code class="bash">$ ./configure
</code></pre>
  <p>
   If you get an error complaining that no compiler has been installed, then that means Linux development tools need to be installed on the computer.
  </p>
  <p>
   On Debian or RPM based Linux distros, development tools can be installed through one of the two package manager commands.  To install development tools on Debian-based systems, run the following command from a terminal window with root privileges.
  </p>
  <pre><code class="bash">$ sudo apt-get install -y build-essential
</code></pre>
  <p>
   To install developments tool on RPM based Linux distros run the following command with root privileges from a terminal.
  </p>
  <pre><code class="bash">$ sudo yum groupinstall -y 'Development Tools'
</code></pre>
  <p>
   Once the development tools are installed, run the
   <strong>
    configure
   </strong>
   command again from the terminal window in the root folder of the source code.
   <strong>
    DO NOT RUN
   </strong>
   the
   <strong>
    configure
   </strong>
   command with root privileges.
  </p>
  <p>
   The
   <strong>
    configure
   </strong>
   command should execute quickly.  Once
   <strong>
    configure
   </strong>
   successfully executes, run the
   <strong>
    make
   </strong>
   command.
   <strong>
    DO NOT RUN
   </strong>
   the
   <strong>
    make
   </strong>
   command with root privileges.
  </p>
  <pre><code class="bash">$ make
</code></pre>
  <p>
   The
   <strong>
    make
   </strong>
   command will take a few minutes to complete depending upon the hardware specifications of your computer.
  </p>
  <blockquote>
   <p>
    <strong>
     Testing the Build Results
    </strong>
    <br/>
    If you desire to test the results of the build process before installing it, execute the following command from a terminal window before executing the
    <strong>
     make install
    </strong>
    command.
    <br/>
   </p>
   <blockquote>
   </blockquote>
   <pre><code class="bash">$ make test
</code></pre>
   <p>
    The testing in process will take several minutes to complete.  Some tests may fail, yet, Node.js will work as expected.  Feel free to explore why the tests failed, but most likely all is well.
    <br/>
   </p>
  </blockquote>
  <p>
   Once the
   <strong>
    make
   </strong>
   command completes, execute the
   <strong>
    make install
   </strong>
   command with root privileges from the terminal.  Root privileges are needed to copy files to and make symbolic links in privileged system folders.  Only run commands as root when absolutely needed.
  </p>
  <pre><code class="bash">$ sudo make install
</code></pre>
  <p>
   Once the
   <strong>
    make install
   </strong>
   command completes, Node.js is installed and can be used.
  </p>
  <h3>
   Testing the Installation
  </h3>
  <p>
   Once Node.js is installed (regardless of installation method), it is used by running the
   <strong>
    node
   </strong>
   command from the a terminal.  Node.js can be used in REPL mode or it can be used to execute JavaScript files.  To execute Node.js in REPL mode, run the node executable from the command line.
  </p>
  <pre><code class="bash">$ node
</code></pre>
  <p>
   You will be presented with a Node.js command prompt from which JavaScript commands can be executed.  To execute a JavaScript file with Node.js, run the node executable like this:
  </p>
  <pre><code class="bash">$ node somefile.js
</code></pre>
  <p>
   In this example,
   <strong>
    somefile.js
   </strong>
   represents a JavaScript source code file.
  </p>
  <p>
   To simply view the version number of the installed Node.js executable, execute the following command from the terminal window.
  </p>
  <pre><code class="bash">$ node -v
</code></pre>
  <p>
   If a version number is displayed, then Node.js has been installed successfully.
  </p>
  <h4>
   Exercise - Install Node.js
  </h4>
  <p>
   Step 1. If your computer's platform is Windows or OS X, download the installer and execute it.  Select, the default options for completing the installation.  If you computer's platform is Linux, download and install Node.js using the appropriate package manager.  Once installation is complete, run the node executable to output the version number.
  </p>
  <p>
   Step 2. Download the  pre-compiled binaries for your platform.  Extract the binaries and change to the executables folder.  Run the node executable in the folder and output the version number.
  </p>
  <p>
   <strong>
    Exercise Complete!
   </strong>
  </p>
  <p>
   <strong>
    Challenge:
   </strong>
   If your platform is Linux, download the source code, compile it and run the resulting node.js executable outputing the version number.  If you cannot compile the source code because the compiler is missing be sure to download and install the development tools packages.
  </p>
  <h2>
   Node.js Upgrading
  </h2>
  <p>
   Upgrading Node.js is fairly simple.  For installations using the installer application or Linux Package Managers, upgrading is as simply as running the latest installer or updating the installed packages.
  </p>
  <h3>
   Installer Application Upgrade
  </h3>
  <p>
   Download the latest Node.js version of the installer application for your computer's platform and architecture and execute it.  It will upgrade your computer's version of Node.js.
  </p>
  <h3>
   Linux Package Manager
  </h3>
  <p>
   For Node.js installations performed via Linux Package Managers, upgrading Node.js is nothing more than performing a package upgrade.
  </p>
  <p>
   To upgrade Node.js with Debian Package Manager based Linux distros, run the following command as root (normally via sudo).
  </p>
  <pre><code class="bash">$ sudo apt-get upgrade -y nodejs
</code></pre>
  <p>
   To upgrade Node.js on RPM based Linux distros, run the following as root (normally via sudo).
  </p>
  <pre><code class="bash">$ sudo yum update -y nodejs
</code></pre>
  <p>
   After the update is performed, confirmation of the update can be done by executing the following command from a terminal.
  </p>
  <pre><code class="bash">$ node -v
</code></pre>
  <p>
   The version number displayed will match the version upgraded to, if the upgrade was successful.
  </p>
  <h3>
   Pre-Compiled Binaries
  </h3>
  <p>
   To update an existing Node.js installation with latest pre-compiled binaries simply perform the same steps as installing a pre-compiled Node.js installation.
  </p>
  <h3>
   Locally Compiled Source Code
  </h3>
  <p>
   To update the version of Node.js on a computer with a locally compiled version, simply repeat the steps listed for the initial installation of Node.js from locally compiled source code.
  </p>
  <h3>
   Update Confirmation
  </h3>
  <p>
   After the update is performed, confirmation of the update can be done by executing the following command from a terminal.
  </p>
  <pre><code class="bash">$ node -v
</code></pre>
  <p>
   The version number displayed will match the version upgraded to, if the upgrade was successful.
  </p>
  <p>
   From time to time, when installing, uninstalling, and updating Node.js, the terminal in Linux will give an odd error that looks like this.
  </p>
  <pre><code class="bash">$ node
-bash: /usr/sbin/node: No such file or directory
</code></pre>
  <p>
   If you type
   <strong>
    /usr/bin/node
   </strong>
   and press enter Node.js runs fine.  The challenge is that
   <strong>
    /usr/bin
   </strong>
   is in your path and the shell is not finding Node.js there.  To solve the problem, type the following command in the terminal.
  </p>
  <pre><code class="bash">$ hash -r
</code></pre>
  <p>
   Then, try to run Node.js again by typing
   <strong>
    node
   </strong>
   at the command prompt and pressing enter.
  </p>
  <h2>
   Using the Read-Eval-Print-Loop
  </h2>
  <h3>
   Introduction
  </h3>
  <p>
   What is the Read-Eval-Print-Loop, more commonly referred to as REPL?  When Node.js is executed from a terminal with no JavaScript file specified, it runs as an interactive shell.  The Node.js interactive shell reads JavaScript commands entered by the user, evaluates the command, then prints the result of the evaluation.  After printing the evaluation, the user enters a new JavaScript command that is executed within the context of the previously entered and evaluated commands.
  </p>
  <h3>
   JavaScript Commands: Declarations, Expressions and Block Statements
  </h3>
  <p>
   The REPL has many useful purposes including debugging and trying out new JavaScript commands.  In the REPL, JavaScript commands can be a declaration, expression or block statement.  Also, they can be single line or multi-line.
   <br/>
   <strong>
    Example:
   </strong>
   Declarations
  </p>
  <pre><code class="javascript">&gt; var x = 2;
undefined
&gt; function f() {
... return "some value";
... }
undefined
</code></pre>
  <p>
   <strong>
    Example:
   </strong>
   Expressions
  </p>
  <pre><code class="javascript">&gt; 4 + 6
10
&gt; x * 5
10
</code></pre>
  <p>
   <strong>
    Example:
   </strong>
   Block Statement
  </p>
  <pre><code class="javascript">&gt; if (x &gt; 4) {
... console.log("greater than 4");
... } else {
... console.log("less than 4");
... }
less than 4
undefined
</code></pre>
  <h4>
   Exercise - Interactive Shell
  </h4>
  <p>
   Step 1. To start the interactive shell, execute the following command from the terminal.
  </p>
  <pre><code class="bash">$ node
</code></pre>
  <p>
   Step 2. You will be presented with a Node.js command prompt that looks like this:
  </p>
  <pre><code class="bash">&gt;
</code></pre>
  <p>
   Step 3. From Node.js command prompt, JavaScript and special Node.js commands can be entered.  For example, type the following command:
  </p>
  <pre><code class="javascript">&gt; console.log("Hello Node.js!");
</code></pre>
  <p>
   The output will look similar to this:
  </p>
  <pre><code class="javascript">&gt; console.log("Hello Node.js!");
Hello Node.js!
undefined
&gt;
</code></pre>
  <p>
   The text "Hello Node.js!" is the output of the
   <strong>
    console.log
   </strong>
   command.  The text "undefined" refers to the return value of
   <strong>
    console.log
   </strong>
   .  Since
   <strong>
    console.log
   </strong>
   does not return a value, the output to the screen is
   <strong>
    undefined
   </strong>
   .  Every JavaScript command evaluated by Node.js will output the return value of the command, even if there is no return value.  This is a JavaScript feature more than a Node.js oddity.  In JavaScript, all expressions return a value even if the value is simply
   <strong>
    undefined
   </strong>
   .
  </p>
  <p>
   In addition to a single line expression, multi-line expressions can be entered.
  </p>
  <p>
   <strong>
    Exercise Complete!
   </strong>
  </p>
  <h3>
   Interactive Shell Control Commands
  </h3>
  <p>
   In addition to JavaScript expression and declarations, there are several Node.js control commands that can be entered within the interactive shell.  Here is a list of the commands.
  </p>
  <h4>
   Control Command: .help
  </h4>
  <p>
   Displays a list of all shell commands and their descriptions.
  </p>
  <p>
   <strong>
    Example:
   </strong>
   From a Node.js command prompt, type
   <strong>
    .help
   </strong>
   then press
   <strong>
    enter
   </strong>
   .
  </p>
  <pre><code class="javascript">&gt; .help
.break  Sometimes you get stuck, this gets you out
.clear  Alias for .break
.exit   Exit the repl
.help   Show repl options
.load   Load JS from a file into the REPL session
.save   Save all evaluated commands in this REPL session to a file
&gt;
</code></pre>
  <h4>
   Control Command: .exit
  </h4>
  <p>
   Exits the interactive shell.  In addition to
   <strong>
    .exit
   </strong>
   ,
   <strong>
    ctrl+d
   </strong>
   can be used to exit the interactive shell.  Finally, typing
   <strong>
    ctrl+c
   </strong>
   twice exits the interactive shell as well.
  </p>
  <p>
   <strong>
    Example:
   </strong>
   From a Node.js command prompt, type
   <strong>
    .exit
   </strong>
   , then press
   <strong>
    enter
   </strong>
   .
  </p>
  <pre><code class="javascript">&gt; .exit
$
</code></pre>
  <h4>
   Control Command: .break
  </h4>
  <p>
   When typing multi-line commands the
   <strong>
    .break
   </strong>
   command is used to exit the multi-line command if you do not want to complete it.
  </p>
  <p>
   <strong>
    Example:
   </strong>
   Type the following code at a Node.js command prompt, then press
   <strong>
    enter
   </strong>
   .
  </p>
  <pre><code class="javascript">&gt; function f() {
</code></pre>
  <p>
   Observe when you typed the open curly brace and pressed enter, the cursor went to the next line resulting in a multi-line Node.js command.
  </p>
  <pre><code class="javascript">&gt; function f() {
...
</code></pre>
  <p>
   Add some more code like this, and press
   <strong>
    enter
   </strong>
   .
  </p>
  <pre><code class="javascript">&gt; function f() {
... var g = 10;
</code></pre>
  <p>
   The result is another line in the multi-line command.
  </p>
  <pre><code class="javascript">&gt; function f() {
... var g = 10;
...
</code></pre>
  <p>
   Type
   <strong>
    .break
   </strong>
   and press
   <strong>
    enter
   </strong>
   .
  </p>
  <pre><code class="javascript">&gt; function f() {
... var g = 10;
... .break
</code></pre>
  <p>
   Observe, how you exited the multi-line statement and returned to a normal Node.js command prompt.
  </p>
  <pre><code class="javascript">&gt; function f() {
... var g = 10;
... .break
&gt;
</code></pre>
  <p>
   At the Node.js command prompt, type
   <strong>
    f
   </strong>
   and press
   <strong>
    enter
   </strong>
   .
  </p>
  <pre><code class="javascript">&gt; f
</code></pre>
  <p>
   Observe how the result says
   <strong>
    f
   </strong>
   is undefined.
  </p>
  <pre><code class="javascript">ReferenceError: f is not defined
    at repl:1:2
    at REPLServer.self.eval (repl.js:110:21)
    at Interface.&lt;anonymous&gt; (repl.js:239:12)
    at Interface.emit (events.js:95:17)
    at Interface._onLine (readline.js:203:10)
    at Interface._line (readline.js:532:8)
    at Interface._ttyWrite (readline.js:761:14)
    at ReadStream.onkeypress (readline.js:100:10)
    at ReadStream.emit (events.js:98:17)
    at emitKey (readline.js:1096:12)
</code></pre>
  <p>
   Because the
   <strong>
    .break
   </strong>
   control command was used to exit the multi-line command, the function object was not defined.
  </p>
  <h4>
   Control Command: .save
  </h4>
  <p>
   Saves the current REPL session to a file.
  </p>
  <p>
   <strong>
    Example:
   </strong>
   From a Node.js command prompt, type the following commands, pressing
   <strong>
    enter
   </strong>
   after each command.
  </p>
  <pre><code class="javascript">&gt; var x = 2;
undefined
&gt; var y = 3;
undefined
&gt; x*y
6
</code></pre>
  <p>
   Observe, how after each command, the expression value of the command is displayed on the screen.  Next, type
   <strong>
    .save demo.js
   </strong>
   and press
   <strong>
    enter
   </strong>
   , to save the REPL session commands to a file named
   <strong>
    demo.js
   </strong>
   .
  </p>
  <pre><code class="javascript">&gt; var x = 2;
undefined
&gt; var y = 3;
undefined
&gt; x*y
6
&gt; .save demo.js
</code></pre>
  <p>
   Exit the Node.js command prompt, and view the contents of
   <strong>
    demo.js
   </strong>
   .
  </p>
  <pre><code class="javascript">&gt; .exit
</code></pre>
  <pre><code class="bash">$ more demo.js
</code></pre>
  <p>
   The output will look like this.
  </p>
  <pre><code class="bash">$ more demo.js
var x = 2;
var y = 3;
x*y
$
</code></pre>
  <p>
   The JavaScript file is a listing of the commands typed during the Node.js REPL session.
  </p>
  <h4>
   Control Command: .load
  </h4>
  <p>
   Loads a saved REPL session (or any JavaScript code) from a file.
  </p>
  <p>
   <strong>
    Example:
   </strong>
   Using the
   <strong>
    demo.js
   </strong>
   file from the
   <strong>
    .save
   </strong>
   example, type the following from a Node.js command prompt and press
   <strong>
    enter
   </strong>
   .
  </p>
  <pre><code class="javascript">&gt; .load demo.js
</code></pre>
  <p>
   Observe the result of loading the file.
  </p>
  <pre><code class="javascript">&gt; .load demo.js
&gt; var x = 2;
undefined
&gt; var y = 3;
undefined
&gt; x*y
6
&gt;
</code></pre>
  <p>
   Each line of the file is executed, displaying the value of each expression.
  </p>
  <p>
   From the Node.js command prompt, type the following command, and press
   <strong>
    enter
   </strong>
   .
  </p>
  <pre><code class="javascript">&gt; x+y
</code></pre>
  <p>
   Observe the outputed value of 5.
  </p>
  <pre><code class="javascript">&gt; x+y
5
&gt;
</code></pre>
  <p>
   When a JavaScript file is loaded, its variable and function declaration are loaded into the context of the REPL environment to be used by future commands.
  </p>
  <h4>
   Control Command: .clear
  </h4>
  <p>
   Clears the context when the REPL is started by executing the
   <strong>
    start
   </strong>
   function provided by the
   <strong>
    repl
   </strong>
   module.
  </p>
  <p>
   <strong>
    Example:
   </strong>
   Create a file named
   <strong>
    repldemo.js
   </strong>
   , and add the following JavaScript code to it.
  </p>
  <pre><code class="javascript">var repl = require('repl');
repl.start({ prompt: "MyREPL&gt; " }).context.message = 'Some message!';
</code></pre>
  <p>
   When executed, this JavaScript file create a custom REPL environment by configuring a custom prompt and initializing a variable named message with a value of 'Some message!'.  To execute this JavaScript file, type the following command into a terminal and press
   <strong>
    enter
   </strong>
   .
  </p>
  <pre><code class="bash">$ node repldemo.js
</code></pre>
  <p>
   A Node.js command prompt will appears that looks like this.
  </p>
  <pre><code class="javascript">MyREPL&gt;
</code></pre>
  <p>
   At the custom Node.js command prompt type the following command and press
   <strong>
    enter
   </strong>
   .
  </p>
  <pre><code class="javascript">MyREPL&gt; message
</code></pre>
  <p>
   The output will look like this.
  </p>
  <pre><code class="javascript">MyREPL&gt; message
'Some message!'
MyREPL&gt;
</code></pre>
  <p>
   Next, type
   <strong>
    .clear
   </strong>
   , and press
   <strong>
    enter
   </strong>
   .
  </p>
  <pre><code class="javascript">MyREPL&gt; .clear
</code></pre>
  <p>
   The result of executing the
   <strong>
    .clear
   </strong>
   Node.js control command is.
  </p>
  <pre><code class="javascript">MyREPL&gt; .clear
Clearing context...
MyREPL&gt;
</code></pre>
  <p>
   Finally, type
   <strong>
    message
   </strong>
   , and press
   <strong>
    enter
   </strong>
   .
  </p>
  <pre><code class="javascript">MyREPL&gt;message
ReferenceError: message is not defined
    at repl:1:2
    at REPLServer.self.eval (repl.js:112:21)
    at Interface.&lt;anonymous&gt; (repl.js:239:12)
    at Interface.emit (events.js:95:17)
    at Interface._onLine (readline.js:203:10)
    at Interface._line (readline.js:532:8)
    at Interface._ttyWrite (readline.js:761:14)
    at ReadStream.onkeypress (readline.js:100:10)
    at ReadStream.emit (events.js:98:17)
    at emitKey (readline.js:1096:12)
MyREPL&gt;
</code></pre>
  <p>
   Because the context was cleared with the
   <strong>
    .clear
   </strong>
   command, the variable
   <strong>
    message
   </strong>
   is no longer defined.  The
   <strong>
    .clear
   </strong>
   control command only works in this way within custom REPLs.  When used in Node.js's standard REPL,
   <strong>
    .clear
   </strong>
   is an alias of
   <strong>
    .break
   </strong>
   .
  </p>
  <h4>
   Exercise - Interactive Shell Control Commands
  </h4>
  <p>
   Step 1.  From a terminal, start the Node.js interactive shell.
  </p>
  <p>
   Step 2. Type in the following function.
  </p>
  <pre><code class="javascript">function formatName(firstName, lastName) {
  return String(firstName) + " " + String(lastName);
}
</code></pre>
  <p>
   Step 3. Type the following command.
  </p>
  <pre><code class="javascript">&gt; formatName("John", "Doe");
</code></pre>
  <p>
   Step 4. Save the session to a file named
   <strong>
    sample.js
   </strong>
   using a control command.
  </p>
  <p>
   Step 5. Exit the Node.js interactive shell using a control command.
  </p>
  <p>
   Step 6. Start the Node.js interactive shell again.
  </p>
  <p>
   Step 7. Load the
   <strong>
    sample.js
   </strong>
   file.  The loaded JavaScript will execute successfully.
  </p>
  <p>
   <strong>
    Exercise Complete!
   </strong>
  </p>
  <h2>
   Node.js Packages - NPM
  </h2>
  <p>
   The Node Package Manager is a package manager for Node.js.  It's packages are not limited Node.js, any kind of JavaScript module can be distributed as a Node.js package.  Node.js packages can be created, installed, updated and uninstalled via the
   <strong>
    npm
   </strong>
   command line tool.
  </p>
  <h3>
   NPM Command
  </h3>
  <p>
   The
   <strong>
    npm
   </strong>
   performs many operations to help manage Node Packages locally and globally.  To see a full list of commands that can executed with
   <strong>
    npm
   </strong>
   , type
   <strong>
    npm
   </strong>
   in a terminal, then press
   <strong>
    enter
   </strong>
   .  The following sections will cover many of the commands commonly used by administrators and developers when working with Node.js.
  </p>
  <p>
   When using NPM errors can occurs.  When errors occur, the errors are displayed on the screen and logged to to a file named
   <strong>
    npm-debug.log
   </strong>
   .
  </p>
  <h3>
   Project/Package Initialization
  </h3>
  <p>
   Node.js projects can be configured with a package.json file to store metadata about a Node.js project including its package dependencies.  To setup a package.json file, open a command prompt, change to the project folder, then run the following command.
  </p>
  <pre><code class="bash">$ npm init
</code></pre>
  <p>
   A number of questions will be asked.  The default values can be accepted or specific values can be entered.  The result is a JSON file named
   <strong>
    package.json
   </strong>
   that will look similar to this.
  </p>
  <pre><code class="json">{
  "name": "MyProject",
  "version": "1.0.0",
  "description": "Description for MyProject",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "Some Author",
  "license": "Apache2"
}
</code></pre>
  <p>
   Once this file is created, package dependencies can be saved to the package.json file.  The package.json file can be viewed from two perspectives - it is a project configuration file but it can also serve as the package information file for distributing a project as an NPM package.  For ordinary development, this file will be viewed as a project configuration file; but, the project could be distributed as its own package as well.
  </p>
  <h4>
   Exercise - Project Setup
  </h4>
  <p>
   Step 1. Open a terminal, and change to the folder on your computer where you create new projects.  Create a new folder named
   <strong>
    myproject
   </strong>
   .  Change to the new folder.
  </p>
  <p>
   Step 2.  Type
   <strong>
    npm init
   </strong>
   , and press
   <strong>
    enter
   </strong>
   .  Accept the default options, and complete the file setup.
  </p>
  <p>
   Step 3. Create the following folders,
   <strong>
    myproject/app
   </strong>
   ,
   <strong>
    myproject/dist
   </strong>
   .
   <em>
    Note:
   </em>
   <strong>
    myproject
   </strong>
   refers to the folder created in
   <strong>
    Step 1
   </strong>
   and is merely specified to show the desired folder structure.  The
   <strong>
    app
   </strong>
   folder will contain the source code files you will edit.  The
   <strong>
    dist
   </strong>
   folder will contain the code files that will actually run on the web server.  We will add a mechanism to automatically process and copy the files from the folder
   <strong>
    app
   </strong>
   folder to the
   <strong>
    dist
   </strong>
   folder in a future exercise.
  </p>
  <p>
   <strong>
    Exercise Complete!
   </strong>
  </p>
  <h3>
   Installing Packages
  </h3>
  <p>
   Node.js packages can be installed locally in a project or globally on a system.  Local packages allow project specific versions of packages to be installed.  On OSX and Linux Systems, installing a package globally requires root level access.
  </p>
  <p>
   To install a package locally within a project, change to the project folder, then run the following command.
  </p>
  <pre><code class="bash">$ npm install &lt;package name&gt;
</code></pre>
  <p>
   In addition to installing single packages, multiple packages may be installed simultaneously.
  </p>
  <pre><code class="bash">$ npm install &lt;package 1 name&gt; &lt;package 2 name&gt; &lt;package 3 name&gt;
</code></pre>
  <p>
   Node.js project package dependencies can be saved to the package.json file using one of three options available when installing Node.js packages:
   <strong>
    save
   </strong>
   ,
   <strong>
    save-dev
   </strong>
   , and
   <strong>
    save-optional
   </strong>
   .
  </p>
  <p>
   The
   <strong>
    save
   </strong>
   option is for packages that are needed for the project to execute such as a web server package.  The
   <strong>
    save-dev
   </strong>
   option is for packages that are needed for development such as a CSS minimizer.  The
   <strong>
    save-optional
   </strong>
   option is for packages that are not required for execution of the project.
  </p>
  <p>
   To save an installed to package.json file, add the
   <strong>
    save
   </strong>
   option.
  </p>
  <pre><code class="bash">$ npm install &lt;package name&gt; --save
</code></pre>
  <p>
   If the package is used for development purposes only, then use the
   <strong>
    save-dev
   </strong>
   option.
  </p>
  <pre><code class="bash">$ npm install &lt;package name&gt; --save-dev
</code></pre>
  <p>
   To save an optional package to the package.json file, type the following command.
  </p>
  <pre><code class="bash">$ npm install &lt;package name&gt; --save-optional
</code></pre>
  <p>
   To install a package globally run the following command.
  </p>
  <pre><code class="bash">$ npm install -g &lt;package name&gt;
</code></pre>
  <p>
   Observe the
   <strong>
    g
   </strong>
   option used after the
   <strong>
    install
   </strong>
   command.  The
   <strong>
    g
   </strong>
   option signifies the installation is supposed to be global.
  </p>
  <p>
   When a package is installed locally, its downloaded to the
   <strong>
    node_modules
   </strong>
   folder of the current project.  When a package is installed globally, its downloaded to the node installation folder which is generally
   <strong>
    /usr/local
   </strong>
   for a default Node.js installation on Linux and Mac.  For Windows, the global folder is within the user's folder:
   <strong>
    C:\Users\SomeUser\AppData\Roaming\npm
   </strong>
   .
  </p>
  <p>
   A package should only be installed globally if you intend to invoke it from the command line.  Otherwise, the package should be installed locally and referenced with the
   <strong>
    require
   </strong>
   method within your JavaScript code.  Some packages such as
   <strong>
    Grunt
   </strong>
   , are distributed with two packages, one package should be installed locally and a second command line support package that should be installed globally.  In those cases, the following commands would be executed from the project folder.
  </p>
  <pre><code class="bash">$ npm install grunt

$ npm install -g grunt-cli
</code></pre>
  <p>
   Observe that the first package is installed locally, while the second package is installed globally and provides command line access to Grunt.
  </p>
  <h4>
   Exercise - NPM Package Installation
  </h4>
  <p>
   Step 1. Install the following packages as normal project dependencies.  Depending upon your system's configuration, you may need to install these as
   <strong>
    root
   </strong>
   using
   <strong>
    sudo
   </strong>
   .
  </p>
  <ul>
   <li>
    body-parser
   </li>
   <li>
    express
   </li>
   <li>
    jquery
   </li>
   <li>
    q
   </li>
   <li>
    sqlite3
   </li>
   <li>
    ws
   </li>
   <li>
    angular
   </li>
   <li>
    bootstrap
   </li>
  </ul>
  <p>
   Step 2. Install the following packages as project development dependencies.
  </p>
  <ul>
   <li>
    grunt
   </li>
   <li>
    grunt-browserify
   </li>
   <li>
    grunt-contrib-copy
   </li>
   <li>
    grunt-contrib-cssmin
   </li>
   <li>
    grunt-contrib-less
   </li>
   <li>
    grunt-contrib-watch
   </li>
   <li>
    grunt-contrib-uglify
   </li>
   <li>
    browserify-shim
   </li>
  </ul>
  <p>
   Step 3. Install the following packages globally.
  </p>
  <ul>
   <li>
    browserify
   </li>
   <li>
    grunt-cli
   </li>
   <li>
    less
   </li>
  </ul>
  <p>
   Step 4. Open the
   <strong>
    package.json
   </strong>
   file in a text editor, and add the following section of code.  The first few lines and last line of the original file are included to show you where to add the
   <strong>
    browserify
   </strong>
   and
   <strong>
    browserify-shim
   </strong>
   configuration.
  </p>
  <pre><code class="javascript">    "grunt-contrib-watch": "^0.6.1"
  },
  "browserify": {
    "transform": [
      "browserify-shim"
    ]
  },
  "browserify-shim": {
    "angular": "global:angular"
  }
}
</code></pre>
  <p>
   These settings are needed to make Angular.js compatible with the CommonJS module system. Save the file, and close it.
  </p>
  <p>
   <strong>
    Exercise Complete!
   </strong>
  </p>
  <h3>
   Updating Packages
  </h3>
  <p>
   Many NPM packages are regularly updated; therefore, the global and local packages installed on your system will need to be updated from time to time.  Fortunately, updating NPM packages is a simple process.
  </p>
  <p>
   To update a single local package, change to the project folder, then run the following command.
  </p>
  <pre><code class="bash">$ npm update &lt;package name&gt;
</code></pre>
  <p>
   In addition to updating single packages, multiple packages may be updated simultaneously.
  </p>
  <pre><code class="bash">$ npm update &lt;package 1 name&gt; &lt;package 2 name&gt; &lt;package 3 name&gt;
</code></pre>
  <p>
   To update all of the local packages specified in package.json file, then run the following command from the project folder.
  </p>
  <pre><code class="bash">$ npm update
</code></pre>
  <p>
   To see a list of outdated packages specified in the package.json file without updating them, change to the project folder, then run the following command.
  </p>
  <pre><code class="bash">$ npm outdated
</code></pre>
  <p>
   To update a specific global package, run the following command.
  </p>
  <pre><code class="bash">$ npm update -g &lt;package name&gt;
</code></pre>
  <p>
   Once again, observe the
   <strong>
    g
   </strong>
   option signifying this is an update of a global package.
  </p>
  <h3>
   Uninstall Packages
  </h3>
  <p>
   Uninstalling packages causes them to be removed from a project or from the system globally.  Additionally, options can be specified to remove from the package.json file.
  </p>
  <p>
   To uninstall a local package, open a command prompt, change to the project folder, then run the following command.
  </p>
  <pre><code class="bash">$ npm uninstall &lt;package name&gt;
</code></pre>
  <p>
   In addition to uninstalling single packages, multiple packages may be uninstalled simultaneously.
  </p>
  <pre><code class="bash">$ npm uninstall &lt;package 1 name&gt; &lt;package 2 name&gt; &lt;package 3 name&gt;
</code></pre>
  <p>
   The
   <strong>
    uninstall
   </strong>
   command has an alias named
   <strong>
    rm
   </strong>
   .  Therefore, package can be removed as shown here.
  </p>
  <pre><code class="bash">$ npm rm &lt;package name&gt;
</code></pre>
  <p>
   To uninstall a local package and remove it from the package.json file, open a command prompt, change to the project folder, then run the following command.
  </p>
  <pre><code class="bash">$ npm uninstall &lt;package name&gt; --save
</code></pre>
  <p>
   To remove the package as a development dependency, use the following
   <strong>
    save-dev
   </strong>
   option:
  </p>
  <pre><code class="bash">$ npm uninstall &lt;package name&gt; --save-dev
</code></pre>
  <p>
   To remove the package as an optional dependency, use the following
   <strong>
    save-optional
   </strong>
   option:
  </p>
  <pre><code class="bash">$ npm uninstall &lt;package name&gt; --save-optional
</code></pre>
  <p>
   To remove a package globally, open a command prompt, then type the following command.
  </p>
  <pre><code class="bash">$ npm uninstall -g &lt;package name&gt;
</code></pre>
  <p>
   In addition to
   <strong>
    npm uninstall
   </strong>
   , the command
   <strong>
    npm rm
   </strong>
   can be used with the same options to remove packages as well.
  </p>
  <h3>
   Linking Packages
  </h3>
  <p>
   Linking a package allows you to make a local package be referenced global.  Additionally, other Node.js packages can link to the module to make it a local reference.  This can be useful for developing and debugging multiple packages.  Additionally, packages can referenced without distributing them from a repository.
  </p>
  <p>
   To link a package, change to the package folder and run the following command with root user privileges.
  </p>
  <pre><code class="bash">$ cd &lt;node package folder&gt;

$ sudo npm link
</code></pre>
  <p>
   The result of the command will look similar to this output.
  </p>
  <pre><code class="bash">/usr/local/lib/node_modules/&lt;package name&gt; -&gt; /home/&lt;user&gt;/nodejs/&lt;package name&gt;
</code></pre>
  <p>
   To link the package to  another package, change to the folder of the other package and run the following command.
  </p>
  <pre><code class="bash">$ cd &lt;node package folder&gt;

$ sudo npm link &lt;package name&gt;
</code></pre>
  <p>
   The output of the command will look similar to this.
  </p>
  <pre><code class="bash">/home/&lt;user&gt;/nodejs/&lt;other package name&gt;/node_modules/&lt;package name&gt; -&gt; /usr/local/lib/node_modules/&lt;package name&gt; -&gt; /home/&lt;user&gt;/nodejs/&lt;package name&gt;
</code></pre>
  <p>
   Using the
   <strong>
    require
   </strong>
   function, the module defined in the package can be included in the other package.
  </p>
  <h3>
   Unlinking Packages
  </h3>
  <p>
   Unlinking package reverses the process of linking packages.  To unlink a package from another package, change to the package folder and type the following command.
  </p>
  <pre><code class="bash">$ cd &lt;node package folder&gt;

$ npm unlink &lt;package name&gt;
</code></pre>
  <p>
   The output of the command would be.
  </p>
  <pre><code class="bash">unbuild &lt;node package name&gt;@&lt;node package version&gt;
</code></pre>
  <p>
   To unlink a node package from the global node modules folder, change to the package folder and type the following command with root privileges.
  </p>
  <pre><code class="bash">$ cd &lt;node package folder&gt;

$  npm unlink &lt;package name&gt;
</code></pre>
  <p>
   The output of the command should be.
  </p>
  <pre><code class="bash">unbuild &lt;node package name&gt;@&lt;node package version&gt;
</code></pre>
  <p>
   If you receive an error, type the following command with root privileges.
  </p>
  <pre><code class="bash">sudo npm rm -g &lt;package name&gt;
</code></pre>
  <p>
   This will remove the linked package from the global node modules folder.
  </p>
  <h4>
   Exercise - Link a Local Module to another Module
  </h4>
  <p>
   Step 1. Open a terminal, and create two folders.
  </p>
  <pre><code class="bash">$ mkdir firstmod

$ mkdir secondmod
</code></pre>
  <p>
   Step 2. Change to the
   <strong>
    firstmod
   </strong>
   folder and initialize the package.  Accept the defaults for the package.json creation.
  </p>
  <pre><code class="bash">$ cd firstmod

$ npm init
</code></pre>
  <p>
   Step 3: Create a file named
   <strong>
    index.js
   </strong>
   , then add the following code to it.
  </p>
  <pre><code class="javascript">module.exports = {
  someMethod: function() {
      console.log("some method from first mod!!!!!!");
  }
};
</code></pre>
  <p>
   Save the file, and close it.
  </p>
  <p>
   Step 5. In the terminal, use
   <strong>
    npm
   </strong>
   to link the module.
  </p>
  <pre><code class="bash">npm link
</code></pre>
  <p>
   Note: Depending upon your platform and Node.js configuration, NPM link and unlink commands may require root privileges in order to be executed.
  </p>
  <p>
   Step 6. In the terminal, change to the
   <strong>
    secondmod
   </strong>
   folder.  Run
   <strong>
    npm init
   </strong>
   , accepting the defaults values for the questions asked.
  </p>
  <p>
   Step 7. Link the
   <strong>
    firstmod
   </strong>
   package to the
   <strong>
    secondmod
   </strong>
   package.
  </p>
  <pre><code class="bash">npm link firstmod
</code></pre>
  <p>
   Step 8. Create an
   <strong>
    index.js
   </strong>
   file, then add the following code to it.
  </p>
  <pre><code class="javascript">(function() {

  require("firstmod").someMethod();

}());
</code></pre>
  <p>
   Step 9. From the terminal, run the
   <strong>
    index.js
   </strong>
   file in
   <strong>
    secondmod
   </strong>
   .
  </p>
  <pre><code class="bash">node index.js
</code></pre>
  <p>
   The output will be.
  </p>
  <pre><code class="bash">some method from first mod!!!!!!
</code></pre>
  <p>
   Step 10. To unlink
   <strong>
    firstmod
   </strong>
   , run the following command from the terminal.
  </p>
  <pre><code class="bash">npm unlink firstmod.
</code></pre>
  <p>
   Step 11.  From the terminal, run
   <strong>
    index.js
   </strong>
   with Node.js again.  What is the output and why?
  </p>
  <p>
   Step 12. To complete the unlinking process, change to the
   <strong>
    firstmod
   </strong>
   folder and unlink it with the
   <strong>
    npm -rm
   </strong>
   command
  </p>
  <p>
   <strong>
    Exercise Complete!
   </strong>
  </p>
  <h3>
   Listing Packages
  </h3>
  <p>
   Packages installed for a package can be listed using
   <strong>
    npm ls
   </strong>
   .  The
   <strong>
    ls
   </strong>
   command will list all of the packages and their dependencies that installed for package.
  </p>
  <pre><code class="bash">$ npm ls
</code></pre>
  <p>
   The output will look similar to this.
  </p>
  <pre><code class="bash">├─┬ backbone@1.1.2 extraneous
│ └── underscore@1.7.0
├─┬ bower@1.3.12 extraneous
│ ├── abbrev@1.0.5
│ ├── archy@0.0.2
│ ├─┬ bower-config@0.5.2
│ │ ├── graceful-fs@2.0.3
│ │ ├─┬ optimist@0.6.1
│ │ │ ├── minimist@0.0.10
│ │ │ └── wordwrap@0.0.2
│ │ └── osenv@0.0.3
│ ├── bower-endpoint-parser@0.2.2
</code></pre>
  <p>
   Note: The listing can be very long.
  </p>
  <p>
   The NPM command
   <strong>
    ls
   </strong>
   is an alias for
   <strong>
    npm list
   </strong>
   .  Both can be used interchangeably.  Additionally, its possible to list a single package in a package as shown here.
  </p>
  <pre><code class="bash">$ npm ls grunt
tempproject@1.0.0 /home/demos/tempproject
└── grunt@0.4.5
</code></pre>
  <h3>
   Running Packages
  </h3>
  <p>
   Node.js packages can be configured to be executed with the
   <strong>
    npm
   </strong>
   command.  To configure a Node.js package to support execution via
   <strong>
    npm
   </strong>
   the
   <strong>
    scripts
   </strong>
   section must be added to the
   <strong>
    package.json
   </strong>
   file.
  </p>
  <pre><code class="javascript">"scripts": {
  "start": "grunt",
  "webserver": "node webserver.js"
}
</code></pre>
  <p>
   To execute the
   <strong>
    start
   </strong>
   script, the following command would be executed from a terminal.
  </p>
  <pre><code class="bash">$ npm start
</code></pre>
  <p>
   To execute the
   <strong>
    webserver
   </strong>
   script with NPM, the following command would be executed from a terminal.
  </p>
  <pre><code class="bash">$ npm run webserver
</code></pre>
  <p>
   For custom commands like
   <strong>
    webserver
   </strong>
   , the NPM command
   <strong>
    run
   </strong>
   must be invoked followed by the name of the script.  For built-in scripts such as
   <strong>
    start
   </strong>
   , the
   <strong>
    run
   </strong>
   command is not needed.
  </p>
  <h2>
   Modules
  </h2>
  <p>
   Node.js modules Node.js modules follow the CommonJS module specification.
  </p>
  <h3>
   Create a Custom Module
  </h3>
  <p>
   Creating a custom module is very simple.  Open a text editor, and add the following code.
  </p>
  <pre><code class="javascript">module.exports = function () {
  "use strict";

  return {
       doSomething: function() {
          console.log("did something");
     }
  };
};
</code></pre>
  <p>
   Basically, the CommonJS module pattern requires creating a function that returns the module object.  The function is them assigned to the
   <strong>
    module.exports
   </strong>
   property.
  </p>
  <h3>
   Using a Module
  </h3>
  <p>
   To use a module in Node.js, the
   <strong>
    require
   </strong>
   command is used.  The
   <strong>
    require
   </strong>
   command allows you to include a module provided by an NPM package or a JavaScript file name.
  </p>
  <p>
   To require a module that is an NPM package, the
   <strong>
    require
   </strong>
   is used as follows.
  </p>
  <pre><code class="javascript">var someModule = require("some-module");
</code></pre>
  <p>
   To require a module using a JavaScript filename,
   <strong>
    require
   </strong>
   can be called as follows.
  </p>
  <pre><code class="javascript">var someModule = require("./js/some-module");
</code></pre>
  <p>
   Notice, the
   <strong>
    .js
   </strong>
   is not explicitly stated in the filename.  The
   <strong>
    .js
   </strong>
   is assumed and will be applied when the file is loaded up by the
   <strong>
    require
   </strong>
   function.
  </p>
  <p>
   Once a module is loaded up, the JavaScript object returned from
   <strong>
    require
   </strong>
   is used like any other JavaScript object.
  </p>
  <pre><code class="javascript">someModule.doSomething();
</code></pre>
  <h4>
   Exercise - Create Application Module
  </h4>
  <p>
   Step 1. From a terminal, change to the
   <strong>
    app
   </strong>
   folder.
  </p>
  <p>
   Step 2. Create a new file named
   <strong>
    index.html
   </strong>
   , add the following code to it.
  </p>
  <pre><code class="html">&lt;!DOCTYPE html&gt;

&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Angular.js Project Scaffolding&lt;/title&gt;
    &lt;link href="css/bootstrap.min.css" type="text/css" rel="stylesheet"&gt;
    &lt;link href="css/bootstrap-theme.min.css" type="text/css" rel="stylesheet"&gt;
    &lt;link href="css/app.min.css" type="text/css" rel="stylesheet"&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div ng-app="MyApp"&gt;
      &lt;div ng-controller="MyCtrl"&gt;
        &lt;h1&gt;{{message}}&lt;/h1&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;script src="js/angular.min.js"&gt;&lt;/script&gt;
    &lt;script src="js/app.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
  <p>
   Save the file, and close it.
  </p>
  <p>
   Step 3. From the terminal, create a new folder named
   <strong>
    js
   </strong>
   in the
   <strong>
    app
   </strong>
   folder.  Change to the
   <strong>
    js
   </strong>
   folder.
  </p>
  <p>
   Step 4. Create a new file named
   <strong>
    app.js
   </strong>
   , and add the following code to it.
  </p>
  <pre><code class="javascript">module.exports = (function(global, $, angular) {
  "use strict";

  require("./app.constants.js");

  return angular.module("MyApp", ["MyApp.Constants"])
    .controller("MyCtrl", ["$scope", "Greeting", function($scope, Greeting) {
     $scope.message = Greeting;
   }]);

}(window || global, require('jquery'), require("angular")));
</code></pre>
  <p>
   Save the file, and close it.  This file will be the main module of the application.
  </p>
  <p>
   Step 5. Create a new file named
   <strong>
    app.constants.js
   </strong>
   , and add the following code to it.
  </p>
  <pre><code class="javascript">module.exports = (function(global, $, angular) {
  "use strict";

  return angular.module("MyApp.Constants", [])
    .constant("Greeting", "Hello World!!!!");

}(window || global, require('jquery'), require("angular")));
</code></pre>
  <p>
   Save the file, and close it.  This file will be the constants module of the application.
  </p>
  <p>
   Step 6. From the terminal, change to the
   <strong>
    app
   </strong>
   folder.  Create a new folder named
   <strong>
    less
   </strong>
   in the
   <strong>
    app
   </strong>
   folder.  Change to the
   <strong>
    less
   </strong>
   folder.
  </p>
  <p>
   Step 7. Create a new file named
   <strong>
    app.less
   </strong>
   , add the following code to the file.
  </p>
  <pre><code class="less">h1 { color:blue; }
</code></pre>
  <p>
   Save the file, and close it.
  </p>
  <p>
   <strong>
    Exercise Complete!
   </strong>
  </p>
  <h2>
   Web Server
  </h2>
  <p>
   Node.js provides several modules for configuring and running a web server.  The three modules are the
   <strong>
    http
   </strong>
   module, the
   <strong>
    connect
   </strong>
   module, and the
   <strong>
    express
   </strong>
   module.  The following sections will examine each module, demonstrating how to setup a web server.   The lowest level module is the
   <strong>
    http
   </strong>
   module.  It is built into Node.js and does not need to be installed locally into each project.
  </p>
  <h3>
   Http Module
  </h3>
  <p>
   This module provides the simplest web server with very few options.  Requests from web clients can be processed and responses sent in reply.
  </p>
  <h3>
   Connect Module
  </h3>
  <p>
   The Connect module builds upon the
   <strong>
    http
   </strong>
   module to provide additional capabilities.
  </p>
  <p>
   The
   <strong>
    connect
   </strong>
   module is not bundled with Node.js and must be installed using NPM.  To install the module type the following command.
  </p>
  <pre><code class="bash">$ npm install connect --save

$ npm install serve-static --save
</code></pre>
  <p>
   The save option, adds the Connect and Server Static module dependencies to the package.json file.  For more information on packages, see the NPM Packages section.
  </p>
  <p>
   The following example is going to demonstrate how to setup a simple Connect web server that serves static content.  The Connect server comes with several supporting modules.  In this example, the
   <strong>
    serve-static
   </strong>
   module is being referenced to load up static content.
  </p>
  <pre><code class="javascript">var
  http = require("http"),
  connect = require('connect'),
  serveStatic = require('serve-static');
</code></pre>
  <p>
   Observe the three require functions, loading the
   <strong>
    http
   </strong>
   ,
   <strong>
    connect
   </strong>
   and
   <strong>
    serve-static
   </strong>
   modules.  Only module names are needed because the modules have been loaded via NPM into the
   <strong>
    node_modules
   </strong>
   folder for the project.
  </p>
  <p>
   The next snippet of JavaScript demonstrates how to create a Connect web server object and configure a file path to serve static content from.
  </p>
  <pre><code class="javascript">var app = connect();
app.use(serveStatic("./www"));
</code></pre>
  <p>
   Finally, using the
   <strong>
    http
   </strong>
   module a web server is fired up on port 8080 and will serve content from the folder specified in the previous snippet.
  </p>
  <pre><code class="javascript">var webServer = http.createServer(app);
webServer.listen(8080);
</code></pre>
  <h3>
   Express Module
  </h3>
  <p>
   The
   <strong>
    express
   </strong>
   module is not bundled with Node.js and must be installed using NPM.  To install the module type the following command.
  </p>
  <pre><code class="bash">$ npm install express --save

$ npm install body-parser --save
</code></pre>
  <p>
   The save option, adds the connect module dependency to the package.json file.  For more information on packages, see the NPM Packages section.
  </p>
  <p>
   The following example is going to demonstrate how to setup a simple Express web server that serves static content and can process HTTP request bodies.  The Express server comes with several supporting modules.  In this example, the
   <strong>
    body-parser
   </strong>
   module is being referenced to process the body content of HTTP requests.
  </p>
  <pre><code class="javascript">var
  http = require("http"),
  express = require('express'),
  bodyParser = require('body-parser');
</code></pre>
  <p>
   Observe the three require functions, loading the
   <strong>
    http
   </strong>
   ,
   <strong>
    express
   </strong>
   and
   <strong>
    body-parser
   </strong>
   modules.  Only the module names are needed because the modules have been downloaded via NPM into the
   <strong>
    node_modules
   </strong>
   folder for the project.
  </p>
  <p>
   To create the Express server, the
   <strong>
    express
   </strong>
   module is called as a function.
  </p>
  <pre><code class="javascript">var app = express();
</code></pre>
  <p>
   Using the
   <strong>
    use
   </strong>
   function, the Express server can be configured to process many kinds of web server requests and serve up many kinds of content responses.  The code below will serve static web content such as HTML files from the
   <em>
    www
   </em>
   folder.  Also, HTTP requests that have a content body will be able to be parsed by the
   <strong>
    body-parser
   </strong>
   module.  Express supports many kinds of modules to processing requests, one example is a cookie parsing module.
  </p>
  <pre><code class="javascript">app
  .use('/', express["static"]("./www"))
  .use(bodyParser.json());
</code></pre>
  <p>
   Finally, in similar fashion as the Connect server, the Express server will use the
   <strong>
    http
   </strong>
   module to fire up a web server on port 8080 using the configuration specified in the previous snippet.
  </p>
  <pre><code class="javascript">var webServer = http.createServer(app);
webServer.listen(8080);
</code></pre>
  <h4>
   Express - SSL
  </h4>
  <p>
   Setting up Express to support SSL is relatively simple. Instead of using the
   <strong>
    http
   </strong>
   module, the
   <strong>
    https
   </strong>
   module is used.  The
   <strong>
    https
   </strong>
   module functions very similarly to the
   <strong>
    http
   </strong>
   module and supports the same events for creating a server as the
   <strong>
    http
   </strong>
   module supports.
  </p>
  <p>
   Here is some sample code demonstrating how to setup an SSL connection using the
   <strong>
    https
   </strong>
   module.
  </p>
  <pre><code class="javascript">var https = require('https');
var fs = require('fs');

var options = {
  key: fs.readFileSync('keys/key.pem'),
  cert: fs.readFileSync('keys/cert.pem')
};

https.createServer(options, function (req, res) {
  res.status(200).send("hello world\n");
}).listen(8000);
</code></pre>
  <p>
   The
   <strong>
    fs
   </strong>
   module is required to read the private key and the public certificate.  The private key and public certificate are then passed as options in the
   <strong>
    https
   </strong>
   module to initialize and start the SSL-enabled web server.
  </p>
  <p>
   An alternative option to configuring SSL directly on Express is to use a reverse proxy server like Nginx to handle SSL connections allowing the Node.js application to focus on serving content.
  </p>
  <h4>
   Exercise - Create an Express Web Server
  </h4>
  <p>
   Step 1. From a terminal, change to the
   <strong>
    myproject
   </strong>
   folder.
  </p>
  <p>
   Step 2. Create a new file named
   <strong>
    webServer.js
   </strong>
   , add the following code to it.  Copy and paste the code from this document being sure to actually review the code to understand what it is doing.
  </p>
  <pre><code class="javascript">module.exports = function (webServerOptions, dbSqlLiteOptions) {
  "use strict";

  return {
    start: function () {

      var
      http = require("http"),
      express = require('express'),
      bodyParser = require('body-parser'),
      q = require("q"),
      restService = require("./restService.js"),
      webSockets = require("./webSockets.js"),
      app = express(),
      appStart = q.defer(),
      webServer, restServiceCloseDb, webSocketsCloseDb;

      setTimeout(function () {

        // initialize the express web server and set a static route
        app
        .use('/', express["static"](webServerOptions.rootFolder))
        .use(bodyParser.json());

        // if database options are set then add db config and routes
        if (dbSqlLiteOptions) {
          restServiceCloseDb = restService(app, dbSqlLiteOptions).configureRoutes();
        }

        // start listening...
        webServer = http.createServer(app);
        webServer.listen(webServerOptions.port, function () {

          // setup WebSocketServer
          webSocketsCloseDb = webSockets(webServer, dbSqlLiteOptions);

          var cleanUpExecuted = false;

          function cleanUp(fn) {

            var p;
            if (!cleanUpExecuted) {
              p = (fn instanceof Array) ? q.all(fn) : fn();
              p.then(function() {
                console.log("exiting...");
                process.exit();
              });
              cleanUpExecuted = true;
            }
          }

          //do something when app is closing
          process.on('exit', cleanUp.bind(null, [webSocketsCloseDb, restServiceCloseDb]));

          //catches ctrl+c event
          process.on('SIGINT', cleanUp.bind(null, [webSocketsCloseDb, restServiceCloseDb]));

          //catches uncaught exceptions
          process.on('uncaughtException', cleanUp.bind(null, [webSocketsCloseDb, restServiceCloseDb]));

          appStart.resolve();
        });


      }, 0);

      return appStart.promise;
    }
  };

};
</code></pre>
  <p>
   Save the file, and close it.
  </p>
  <p>
   Step 3. Create a new file named
   <strong>
    restService.js
   </strong>
   , add the following code to it.  Copy and paste the code from this document being sure to actually review the code to understand what it is doing.
  </p>
  <pre><code class="javascript">module.exports = function(app, options) {

  var
    myApp = app,
    myOptions = options,
    fs = require("fs"),
    sqlite3 = require("sqlite3").verbose(),
    q = require("q"), db,
    dbExists = fs.existsSync(myOptions.file);

  // create and initialize the database if it does not exist
  if(!dbExists) {

    console.log("Creating database file: " + myOptions.file);
    fs.openSync(myOptions.file, "w");

    db = new sqlite3.Database(myOptions.file);
    db.serialize(function() {

      console.log("Creating tables.");
      db.run("create table widgets (id integer primary key, name text not null, description text, color text, size text, quantity int not null)");
      db.run("create table eventlog (id integer primary key, source text not null, message text not null, severity int not null, created datetime not null)");

      console.log("Creating sample data.");
      db.run("insert into widgets (name, description, color, size, quantity) values ('Red small gear', 'A red gear that is small.', 'red', 'small', 100)");
      db.run("insert into widgets (name, description, color, size, quantity) values ('Green large gear', 'A green gear that is large.', 'green', 'large', 10)");
      db.run("insert into widgets (name, description, color, size, quantity) values ('Blue tiny gear', 'A blue gear that is tiny.', 'blue', 'tiny', 45)");
      db.run("insert into widgets (name, description, color, size, quantity) values ('Orange medium gear', 'An orange gear that is medium.', 'orange', 'medium', 23)");
    });
  } else {
    db = new sqlite3.Database(myOptions.file);
  }

  return {
    configureRoutes: function() {

      // updates an existing record
      myApp.put('/svc/widgets/:widgetId', function(req, res) {
        var widget = req.body;
        db.serialize(function() {
          stmt = db.prepare("update widgets set name = ?, description = ?, color = ?, size = ?, quantity = ? where id = ?");
          stmt.run(widget.name, widget.description, widget.quantity, widget.color, widget.size, req.params.widgetId, function(err) {
            if (err) console.log(err);
            res.json({ widgets_updated: this.changes });
          });
          stmt.finalize();
        });
      });

      // inserts a new record
      myApp.post('/svc/widgets', function(req, res) {
        var widget = req.body;
        db.serialize(function() {
          stmt = db.prepare("insert into widgets (name, description, color, size, quantity) values (?, ?, ?, ?, ?)");
          stmt.run(widget.name, widget.description, widget.color, widget.size, widget.quantity, function(err) {
            if (err) console.log(err);
            res.json({ widget_id: this.lastID});
          });
          stmt.finalize();
        });
      });

      // deletes an existing record with the specified post id
      myApp["delete"]('/svc/widgets/:widgetId', function(req, res) {
        db.serialize(function() {
          stmt = db.prepare("delete from widgets where id = ?");
          stmt.run(req.params.widgetId, function(err) {
            if (err) console.log(err);
            res.json({ widgets_deleted: this.changes });
          });
          stmt.finalize();
        });
      });

      // gets all records
      myApp.get('/svc/widgets', function(req, res) {
        db.serialize(function() {
          db.all("select * from widgets", function(err, widgets) {
            if (err) console.log(err);
            res.json(widgets);
          });
        });
      });

      // gets a record by id
      myApp.get('/svc/widgets/:widgetId', function(req, res) {
        db.serialize(function() {
          db.get("select * from widgets where id = ?", [req.params.widgetId], function(err, widget) {
            if (err) console.log(err);
            res.json(widget);
          });
        });
      });

      // returns a function to close the database
      return function() {
        var deferred = q.defer();
        console.log("closing the database");
        db.close(function() {
          console.log("database closed");
          deferred.resolve();
        });
        return deferred.promise;
      };
    }
  };
};

</code></pre>
  <p>
   Save the file, and close it.
  </p>
  <p>
   Step 4. Create a new file named
   <strong>
    webSockets.js
   </strong>
   , add the following code to it.  Copy and paste the code from this document being sure to actually review the code to understand what it is doing.
  </p>
  <pre><code class="javascript">module.exports = function(webServer, options) {
  "use strict";

  var
    WebSocketServer = require('ws').Server,
    wss = new WebSocketServer({ server: webServer }),
    sqlite3 = require("sqlite3").verbose(),
    db = new sqlite3.Database(options.file);

  wss.on("connection", function(ws) {

    console.log("web sockets open");

    ws.on("error", function(data) {
      console.log("web sockets error");
    });

    ws.on("close", function(data) {
      console.log("web sockets closed");
    });

    ws.on("message", function(data) {
      db.serialize(function() {
        var
          message = JSON.parse(data),
          stmt;

        if (message.messageType === "log") {
          stmt = db.prepare("insert into eventlog (source, message, severity, created) values (?, ?, ?, ?)");
          stmt.run(message.messageData.source, message.messageData.message, message.messageData.severity, new Date(), function(err) {
            if (err) {
              console.log(err);
              ws.send(err);
            } else {
              ws.send("log request processed");
            }
          });
          stmt.finalize();
        }
      });
    });

    // returns a function to close the database
    return function() {
      var deferred = q.defer();
      console.log("closing the database");
      db.close(function() {
        console.log("database closed");
        deferred.resolve();
      });
      return deferred.promise;
    };

  });

};

</code></pre>
  <p>
   Save the file, and close it.
  </p>
  <p>
   <strong>
    Exercise Complete!
   </strong>
  </p>
  <h3>
   Helmet - Express Security
  </h3>
  <h4>
   Overview
  </h4>
  <p>
   Helmet is an Express middleware module that is used to help enhance Express security. Helmet provides protection using Content Security Policy, XSS Filter, Click-Jacking, HTTP Strict Transport Security, and many other features. Essentially, Helmet produces response headers that the browser can choose to use to enforce certain client-side security options. Helmet cannot enforce the client-side security options and for older browsers they may not even support them. Nevertheless, Helmet is very helpful to make your application as secure as it can be on the client-side.
  </p>
  <h4>
   Installation
  </h4>
  <p>
   To get started with Helmet, install the Node.js package within the Node.js application.
  </p>
  <pre><code class="bash">$ npm install helmet --save
</code></pre>
  <p>
   After installing Helmet, the Helmet module must be required as such.
  </p>
  <pre><code class="javascript">var helmet = require('helmet');
</code></pre>
  <p>
   To use the default security settings that Helmet offers, use the following code.
  </p>
  <pre><code class="javascript">var app = Express();
app.use(helmet());
</code></pre>
  <p>
   In many cases, you will want to customize Helmet's configuration. The following sections cover the most common configuration options in more detail.
  </p>
  <h4>
   Content Security Policy (CSP)
  </h4>
  <p>
   Content Security Policy is geared towards protecting against cross-site scripting attacks. It accomplishes this mission by informing the browser of safe sources of content through setting the
   <strong>
    Content-Security-Policy
   </strong>
   response header.  CSP can control the sources for most any kind of content that the browser downloads to display a web page such as JavaScript, images, stylesheets, fonts, etc...
  </p>
  <p>
   Below is some sample code demonstrating how to configure CSP using Helmet.
  </p>
  <pre><code class="javascript">app.use(helmet.csp({
  defaultSrc: ["'self'"],
  scriptSrc: ["'cdnjs.cloudflare.com'"],
  styleSrc: ["'cdnjs.cloudflare.com'"],
  fontSrc: ["'cdnjs.cloudflare.com'"]
}))
</code></pre>
  <p>
   In the example above, Helmet is being configured to allow script, style and font downloads from a popular CDN service.  In addition, to the options listed above there are many more options that are available for configuration.  They include
   <strong>
    imgSrc
   </strong>
   ,
   <strong>
    connectSrc
   </strong>
   ,
   <strong>
    objectSrc
   </strong>
   ,
   <strong>
    mediaSrc
   </strong>
   ,
   <strong>
    frameSrc
   </strong>
   ,
   <strong>
    sandbox
   </strong>
   ,
   <strong>
    eportUri
   </strong>
   ,
   <strong>
    reportOnly
   </strong>
   ,
   <strong>
    setAllHeaders
   </strong>
   , and
   <strong>
    safari5
   </strong>
   .
  </p>
  <p>
   If none of the other source values are set, then the default source value will be used.  The
   <strong>
    self
   </strong>
   value for default means to allow content from the same origin.
  </p>
  <h4>
   XSS Filter
  </h4>
  <p>
   The XSS filter helps to protect vulnerable versions of Internet Explorer against an XSS exploit by sending a header to disable XSS protection.
  </p>
  <pre><code class="javascript">app.use(helmet.xssFilter());
</code></pre>
  <p>
   The header for versions of IE with the exploit looks like this.
  </p>
  <pre><code class="bash">X-XSS-Protection: 0
</code></pre>
  <p>
   For browsers without the exploit, the header looks like this.
  </p>
  <pre><code class="bash">X-XSS-Protection: 1; mode=block
</code></pre>
  <h4>
   Click-Jacking
  </h4>
  <p>
   Click-jacking it attempting to deceive the user into clicking something on a web page other than what they think they are clicking on. Loading familiar web pages into an iFrame with no border then surrounding that content with malicious links can fool a user into clicking something they do not really intend to click. Using the
   <strong>
    X-Frame
   </strong>
   response header, Helmet will indicate to the web browser if the web page can be loaded into an iFrame.
  </p>
  <p>
   To not allow the web page to be loaded into an iFrame, configure Helmet like this.
  </p>
  <pre><code class="javascript">app.use(helmet.xframe());
</code></pre>
  <p>
   The result
   <strong>
    X-Frame-Options
   </strong>
   response header sent to the browser looks like this.
  </p>
  <pre><code class="bash">X-Frame-Options: DENY
</code></pre>
  <p>
   To allow the web page to be loaded into an iFrame within a web page from the same origin, use the following Helment configuration.
  </p>
  <pre><code class="javascript">app.use(helmet.xframe('sameorigin'));
</code></pre>
  <p>
   The result
   <strong>
    X-Frame-Options
   </strong>
   response header sent to the browser looks like this.
  </p>
  <pre><code class="bash">X-Frame-Options: SAMEORIGIN
</code></pre>
  <p>
   To allow the web page to be loaded into an iFrame for a specific URL, use the following Helmet configuration.
  </p>
  <pre><code class="javascript">app.use(helmet.xframe('allow-from', 'http://www.somedomain.com'));
</code></pre>
  <p>
   The result
   <strong>
    X-Frame-Options
   </strong>
   response header sent to the browser looks like this.
  </p>
  <pre><code class="bash">X-Frame-Options: ALLOW-FROM http://www.somedomain.com
</code></pre>
  <h4>
   HTTP Strict Transport Security
  </h4>
  <p>
   HTTP Strict Transport Security (HSTS) is a method to inform user agents to use HTTPS instead of HTTP.  To configure Helmet to use HSTS, review the following code.
  </p>
  <pre><code class="javascript">app.use(helmet.hsts({
  maxAge: 2592000000, // 30 days in milliseconds
  includeSubdomains: true
}));
</code></pre>
  <p>
   The above configuration will inform the user agent to make HTTPS request only for the next 30 days and to include all subdomains.
  </p>
  <p>
   The HSTS response header to the browser will as follows.
  </p>
  <pre><code class="bash">Strict-Transport-Security: max-age=2592000; includeSubDomains
</code></pre>
  <h3>
   Kraken - Express for Larger Applications
  </h3>
  <h4>
   Overview
  </h4>
  <p>
   Kraken is useful for larger Express applications.  Express does little to help isolate controller logic, from views and models and other content.  Kraken lays on top of Express to help structure these components to better facilitate larger application development.
  </p>
  <p>
   From a system administration perspective, the most interesting aspect of Kraken is the security middleware module named Lusca. Lusca can be be used independent of Kraken and functions similar to Helmet.
  </p>
  <h4>
   Lusca Installation
  </h4>
  <p>
   To install Lusca, use NPM to install the
   <strong>
    lusca
   </strong>
   package.
  </p>
  <pre><code class="bash">$ npm install lusca --save
</code></pre>
  <p>
   Once installed, the Lusca module needs to be required as demonstrated here.
  </p>
  <pre><code class="javascript">var lusca = require('lusca');
</code></pre>
  <h4>
   Lusca Configuration
  </h4>
  <p>
   Lusca has many of the same configuration options as Helmet.  Here is a sample Lusca configuration.
  </p>
  <pre><code class="javascript">app.use(lusca({
  csrf: true,
  csp: { policy: {
    'default-src': "'self'",
    'script-src': "'cdnjs.cloudflare.com'",
    'style-src': "'cdnjs.cloudflare.com'",
    'font-src': "'cdnjs.cloudflare.com'"
  }},
  xframe: 'SAMEORIGIN',
  p3p: 'ABCDEF',
  hsts: {maxAge: 2592000, includeSubDomains: true},
  xssProtection: true
}));
</code></pre>
  <p>
   There is one additional options offered by Lusca that is not covered by Helmet.  The
   <strong>
    P3P
   </strong>
   option stands for the Platform for Privacy Preferences Project.  This option communicates to end users what kind of data will be collected from them by the web site.
  </p>
  <h2>
   Scaling Node.js
  </h2>
  <h3>
   Overview
  </h3>
  <p>
   An instance of Node.js is limited to one process with one thread.  This is not so much a Node.js limitation as it is a JavaScript language limitation.  JavaScript both on the client and server is single-threaded.  As mentioned at the beginning of the document, what gives JavaScript and more specifically Node.js in this case, the appearance of concurrency is its fast running event loop that depends upon non-blocking execution achieved through asynchronous programming patterns.  Nevertheless, Node.js can scale through the creation of multiple instances where one instance runs per processor/core.  The management and configuration of the instances can be achieve through several approaches.  When standing up a Node.js web server, the two most commonly used approaches is to utilize the cluster module or use a reverse proxy server to map incoming client connections to multiple Node.js instances.
  </p>
  <h3>
   Cluster Module
  </h3>
  <p>
   Because Node.js is single-threaded, an Express web server cannot serve requests from multiple threads.  To fully utilize computers with multiple processors and multiple cores per processor, multiple Node.js processes (one for each processor/core) can be coordinated from a master Node.js process to serve more requests.  From a stability perspective, if a single web server process crashes for any reason, no more requests will be able to be handled until its restarted.  There is no fault-tolerant, automatic fail over capability available within Node.js when running a single Node.js process instance, of a single-threaded web server.
  </p>
  <p>
   To solve this problem, there is a cluster module that will enable Node.js to run multiple processes, each with their own Express web server.  To utilize the Cluster module, the Cluster NPM package needs to be locally installed, using the following command.
  </p>
  <pre><code class="bash">$ npm install cluster --save
</code></pre>
  <p>
   After the Cluster module is installed, it can be used to launch a Node.js process for each
   <strong>
    CPU
   </strong>
   available on the computer.  According to Node.js, the number of
   <strong>
    CPUs
   </strong>
   is the number of physical processors multipled by the number of cores per processor.
  </p>
  <pre><code class="javascript">(function() {

  "use strict";

  const
    express = require("express"),
    cluster = require("cluster"),
    app = express();

  if (cluster.isMaster) {

    var cpuCount = require('os').cpus().length;

    while (cpuCount--) {
      cluster.fork();
    }

  } else {

    app.get("/", function(req, res) {

      res.send('Hi from worker: ' + cluster.worker.id);

    });

    app.listen(8888);
    console.log("Express App is running with worker id " + cluster.worker.id + "...");

  }

}());
</code></pre>
  <p>
   A single script is used to setup the
   <strong>
    Master
   </strong>
   as well as spawn the
   <strong>
    Child
   </strong>
   processes.
  </p>
  <h3>
   Nginx Reverse Proxy
  </h3>
  <h4>
   Overview
  </h4>
  <p>
   Nginx is a very popular web server that quickly serves static content while using a reverse proxy approach to serving up dynamic content produced by languages such as PHP, .NET, Java and Node.js.  Static content include plain HTML files, image files, JavaScript files, CSS styles and many other kinds of media files.  Nginx efficiently handles requests for static content and even provides caching capabilities.  A reverse proxy is a proxy that stands in front of several non-public servers providing the client a single point of entry and then maps the various client requests to the appropriate non-public server behind the proxy.
  </p>
  <p>
   The first question is why use Nginx (or any web server as reverse proxy) instead of simply standing up Express on its own?  There are many debatable reasons for doing this setup.  Reasons include:
  </p>
  <ul>
   <li>
    Serving static content faster
   </li>
   <li>
    Securely attached to port 80
   </li>
   <li>
    SSL terminate at Nginx instead of managing SSL within Express
   </li>
  </ul>
  <p>
   The second question is why choose Nginx over other options?
  </p>
  <ul>
   <li>
    Nginx is preferred over other web front ends because it is non-blocking as well.
   </li>
  </ul>
  <h4>
   Installing Nginx
  </h4>
  <p>
   Usually Express and Node.js are configured web applications through a proxy web server such as Nginx.  In this section, we are going to learn how to install and configure Nginx to serve Node.js Express web applications.
  </p>
  <p>
   To install Nginx on Debian-based Linux distros, type the following command at a terminal.
  </p>
  <pre><code class="bash">$ apt-get install nginx
</code></pre>
  <p>
   To install Nginx on RPM-based Linux distros, type the following command at a terminal.
  </p>
  <pre><code class="bash">$ yum install nginx
</code></pre>
  <p>
   As part of the package installation for both Debian-based and RPM-based distros, the Nginx web server should start automatically on port 80.  To test, run the following command from a terminal.
  </p>
  <pre><code class="bash">$ curl -i localhost
</code></pre>
  <p>
   If installed successfully, the output will be a
   <strong>
    Welcome to nginx!
   </strong>
   web page.
  </p>
  <p>
   The
   <strong>
    nginx
   </strong>
   executable will be installed
   <strong>
    /usr/sbin/nginx
   </strong>
   .  The
   <strong>
    nginx
   </strong>
   configuration files will be installed in the
   <strong>
    /etc/nginx
   </strong>
   .
  </p>
  <h4>
   Configuring Nginx &amp; Node.js
  </h4>
  <p>
   After the installation of Nginx, an administrator can start, stop and restart the server as well as configure the web server to begin serving web sites. To start, stop and restart Nginx the following commands are used. These commands should work on Debian and Red Hat based Linux distros.
  </p>
  <pre><code class="bash">$ service nginx start

$ service nginx stop

$ service nginx restart
</code></pre>
  <p>
   To setup the reverse proxy for a given site, an
   <strong>
    upstream
   </strong>
   configuration needs to be added.
  </p>
  <pre><code class="bash">upstream &lt;upstream name&gt; {
  server &lt;ip address or domain name&gt;:&lt;port number&gt;;
  server &lt;ip address or domain name&gt;:&lt;port number&gt;;
  keepalive 8;
}
</code></pre>
  <p>
   The
   <strong>
    upstream
   </strong>
   configuration lists the available servers for handling requests from the reverse proxy.  Depending upon the configuration, Nginx will load balance the incoming requests across the servers, handle failure conditions, etc..
  </p>
  <p>
   Within a site's
   <strong>
    server
   </strong>
   configuration, the following settings need to be applied.
  </p>
  <pre><code class="bash">location / {
  proxy_set_header X-Real-IO $remote_addr;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header Host $http_host;
  proxy_set_header X-NginX-Proxy true;

  proxy_pass &lt;upstream name&gt;;
  proxy_redirect off;
}
</code></pre>
  <p>
   A complete site configuration file would look something similar to this.
  </p>
  <pre><code class="bash">upstream node_server {
  server &lt;first node server ip address&gt;:&lt;first node server port&gt;;
  server &lt;second node server ip address&gt;:&lt;second node server port&gt;;
  keepalive 8;
}

server {
  listen 80 default_server;
  listen [::]:80 default_server ipv6only=on;

  server_name &lt;some domain name&gt;;

  location / {
    proxy_set_header X-Real-IO $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_set_header X-NginX-Proxy true;

    proxy_pass http://node_server;
    proxy_redirect off;
  }
}
</code></pre>
  <p>
   When setting up Express behind a proxy like Nginx, the Express application needs to be configured to trust the
   <strong>
    X-Forwarded-For
   </strong>
   header.  To enable Express to trust the proxy header, add the following code to the Express application.
  </p>
  <pre><code class="javascript">app.enable('trust proxy')
</code></pre>
  <h4>
   Firewall
  </h4>
  <p>
   Depending upon the Linux distro you are using there may or may not be firewall rules configured on the server.  Ubuntu 14.04 LTS does not install a firewall by default; therefore, one should be configured.
  </p>
  <p>
   CentOS version 7 comes with a firewall configures with IP Tables.  To open port 80 for HTTP and port 443 for HTTPS, the following IP Tables command should be executed.
  </p>
  <pre><code class="bash">iptables -A IN_public_allow -p tcp --dport 80 -j ACCEPT

iptables -A IN_public_allow -p tcp --dport 443 -j ACCEPT
</code></pre>
  <p>
   Be sure only to open the ports being serviced by Nginx.  The ports connecting to the Node.js Express web server directly should be block from outside access by the server and made available within the local network accessible by Nginx.
  </p>
  <h4>
   Testing Availability
  </h4>
  <p>
   Once the Node.js web server has been configured and is running, loading testing tools can be used to test the availability of the web server under load.  There are numerous tools available, for this course, we will be using a tool named
   <strong>
    Siege
   </strong>
   available from the web site
   <a href="http://www.joedog.org/siege-home/">
   </a>
   <a href="http://www.joedog.org/siege-home/">
    http://www.joedog.org/siege-home/
   </a>
   .  Siege can be installed using the Debian and Red Hat based package management systems.
  </p>
  <p>
   For Debian based Linux distros.
  </p>
  <pre><code class="bash">$ apt-get install -y siege
</code></pre>
  <p>
   For Red Hat based Linux distros.
  </p>
  <pre><code class="bash">$ yum install -y siege
</code></pre>
  <p>
   Once
   <strong>
    siege
   </strong>
   is installed, we can load test a web site using the following command.
  </p>
  <pre><code class="bash">$ siege -c50 -t30s http://&lt;some ip address or domain name&gt;
</code></pre>
  <p>
   With these options, siege will fire up 50 connections and hammer the server for 30 seconds.  To run the load test for a full minute modify the option
   <strong>
    -t30s
   </strong>
   and change it to
   <strong>
    -t1m
   </strong>
   .  When the load test is complete a report similar to this one will be shown.
  </p>
  <pre><code class="bash">** SIEGE 3.0.5
** Preparing 50 concurrent users for battle.
The server is now under siege...
Lifting the server siege...      done.

Transactions:               2098 hits
Availability:             100.00 %
Elapsed time:              29.01 secs
Data transferred:           0.02 MB
Response time:              0.08 secs
Transaction rate:          72.32 trans/sec
Throughput:             0.00 MB/sec
Concurrency:                5.51
Successful transactions:        2098
Failed transactions:               0
Longest transaction:            3.05
Shortest transaction:           0.03
</code></pre>
  <p>
   Transactions are the number of times requests are made from the server.  This number divided by the number of connections will give you the number of times each connection made a server request.
  </p>
  <p>
   Availability is the percent of transactions that were successful.
  </p>
  <p>
   Elapsed time is the length of time the loading testing process ran for.
  </p>
  <p>
   Data transferred is the amount of data transferred to all of the clients during testing.
  </p>
  <p>
   Response time is the average response time to each client for all of the requests.
  </p>
  <p>
   Transaction rate is the average number of transactions per second the server handled.
  </p>
  <p>
   Throughput is the average number of bytes that were transferred to each client per second during testing.
  </p>
  <p>
   Concurrency is the average of simultaneous connections. The higher the number, the worse the performance of the server.
  </p>
  <p>
   Successful transactions are the number requests that received a response with a status code below 400.
  </p>
  <p>
   Failed transactions are those requests which a response with a status code of 400 and greater.
  </p>
  <p>
   Longest and shortest transactions are the number of seconds to complete the longest and short transaction.
  </p>
  <h3>
   Best Option? Cluster or Nginx?
  </h3>
  <p>
   In terms of raw performance for handling request that execute Node.js code, both options are very effective.  Simply, there is no clear winner in terms of raw speed.  Nevertheless, Nginx is most likely a better choice because of the ability to cache and serve static content, configure SSL, as well as, support other non-Node.js web sites on the same server.  Additionally, Nginx can throttle connections and is most likely more reliable and stable than a simple Node.js process running Express.
  </p>
  <p>
   With Nginx publicly facing the clients, how should the Node.js processes running Express behind the scenes be configured?  Should the cluster module be used and have multiple processes running on one port or should multiple processes be started on multiple ports and rely up Nginx to do the load balancing?  Regardless of the Node.js configuration, if multiple upstream servers are specified in the Nginx site configuration then Nginx will always be performing some kind of load balancing.  If Nginx is going to load balance anyway, then there is no need to load balance twice both on the Nginx and Node.js Cluster ends.  Therefore, it is best to let Nginx load balance and run each Node.js process independent of the other on its own port without using the Cluster module.
  </p>
  <h2>
   Keeping Node.js Going
  </h2>
  <h3>
   Overview
  </h3>
  <p>
   There are several options to keeping Node.js running when processes fail.  An older but popular option, is the use of the
   <strong>
    forever
   </strong>
   Node.js package.  A newer, growing in popularity approach, is to use Ubuntu's Monit and Upstart Linux packages to monitor the Node.js server application to keep it running.
  </p>
  <h3>
   Forever
  </h3>
  <p>
   Forever is distributed as two Node.js packages named
   <strong>
    forever
   </strong>
   and
   <strong>
    forever-monitor
   </strong>
   .  The second package,
   <strong>
    forever-monitor
   </strong>
   is only needed if
   <strong>
    forever
   </strong>
   is going to be used programmatically.
  </p>
  <p>
   The
   <strong>
    forever
   </strong>
   package should be install globally because it will be used from the command line.  To install
   <strong>
    forever
   </strong>
   , the following command should be executed from a terminal.  On Linux and Mac OS X, root privileges will be needed.
  </p>
  <pre><code class="bash">npm install -g forever
</code></pre>
  <p>
   Forever offers many commands to manage the continued execution and recovery of Node.js processes.  To see a full listing of the commands, type the following command from a terminal.
  </p>
  <pre><code class="bash">forever --help
</code></pre>
  <p>
   The best way to understand how
   <strong>
    forever
   </strong>
   works is to create test script that throws an error from which Forever can recover from and execute the script again.  Create a new file named
   <strong>
    error.js
   </strong>
   , then add the following code to it.
  </p>
  <pre><code class="javascript">console.log("running script...");
setTimeout(function() {
  console.log("throwing error...");
  throw Error("error occurred");
}, 2000);
</code></pre>
  <p>
   From a terminal type the following command.
  </p>
  <pre><code class="bash">forever -m 5 error.js
</code></pre>
  <p>
   This command will start the script
   <strong>
    error.js
   </strong>
   with Node.js.  After two seconds, an error will be thrown and the script will terminate. Upon termination, Forever will attempt to restart the script. The restart process will occur up to 5 times because of the
   <strong>
    -m
   </strong>
   option.
  </p>
  <p>
   When Forever executes, it writes files to the
   <strong>
    .forever
   </strong>
   in the executing user's home folder. To change the location of Forever's folder, set the FOREVER_ROOT environment variable to the desired path. Make sure the user executing Forever has read and write permissions to the folder.
  </p>
  <p>
   Forever can also because within Javascript code as part of a Node.js application.
  </p>
  <h3>
   Monit &amp; Upstart
  </h3>
  <p>
   Monit and Upstart are applications that are installed on Ubuntu and can be used to monitor and start applications.  Monit and Upstart are not limited to Node.js, they can be used with any kind of application.  Nevertheless, on Ubuntu they have become a popular alternative to using Forever.
  </p>
  <p>
   Upstart is installed as a part of the Ubunto distro.  One some systems Monit may need to be installed using the following command.
  </p>
  <pre><code class="bash">$ apt-get install monit
</code></pre>
  <p>
   To configure Upstart to launch a Node.js application, a configuration file needs to be created in the
   <strong>
    /etc/init
   </strong>
   folder.  Create a new file named "webapp.conf", and add the following configuration to it.
  </p>
  <pre><code class="bash">description "name of your file"
author      "your name"

start on (local-filesystems and net-device-up IFACE=eth0)
stop  on shutdown

respawn                # restart when job dies
respawn limit 5 60     # give up restart after 5 respawns in 60 seconds

script
exec sudo -u &lt;user&gt; /usr/local/bin/node &lt;path to script&gt;/webapp.js &gt;&gt; &lt;path to logs&gt;/webapp.log 2&gt;&amp;1
end script
</code></pre>
  <p>
   After creating the Upstart configuration file, run the following commands to ensure the log file exists and is writable.
  </p>
  <pre><code class="bash">$ sudo touch &lt;path to logs&gt;/webapp.log

$ sudo chmod 775 &lt;path to logs&gt;/webapp.log
</code></pre>
  <p>
   To start the new web application, type the following command in the terminal.
  </p>
  <pre><code class="bash">$ sudo service webapp start
</code></pre>
  <p>
   To verify the web application is running use
   <strong>
    curl
   </strong>
   to retrieve the home page of the web application.
  </p>
  <p>
   After Upstart is configured, then Monit needs to be configured. You will notice that Upstart does have
   <strong>
    respawn
   </strong>
   capabilities and you may question why Monit is needed. Upstart checks for the PID to see if a respawn is needed.  While this is good, it is possible the process is still running but the application is not serving page requests.  In such a situation, Upstart would fail to detect this situation because there would be a running process.  Monit is used to actually ping the web application via HTTP to make sure it is still responding to requests.
  </p>
  <p>
   To configure Monit, we first need to modify Monit's configuration before adding the configuration for the web application.  Open the file
   <strong>
    /etc/monir/monitrc
   </strong>
   in a text editor and uncomment the following lines.
  </p>
  <pre><code class="bash">set httpd port 2812 and
use address localhost  # only accept connection from localhost
allow localhost        # allow localhost to connect to the server and
</code></pre>
  <p>
   Save the file and close it.  Restart the Monit process with following command.
  </p>
  <pre><code class="bash">$ sudo service monit restart
</code></pre>
  <p>
   Finally, we need to create a Monit configuration file for the application.  Create file named
   <strong>
    webapp.monitrc
   </strong>
   in the
   <strong>
    /etc/monit/conf.d
   </strong>
   folder.  Add the following configuration to it.
  </p>
  <pre><code>start "/sbin/start webapp"
stop "/sbin/stop webapp"
if failed port &lt;port number of web app&gt; protocol HTTP
  request /
  with timeout 5 seconds
  then restart
</code></pre>
  <p>
   To start the Monit configuration for
   <strong>
    webapp
   </strong>
   , type the following command in a terminal.
  </p>
  <pre><code class="bash">$ sudo monit start webapp
</code></pre>
  <p>
   Now Monit will be monitoring the
   <strong>
    webapp
   </strong>
   Upstart service. To view the status of Monit, type the following command in a terminal.
  </p>
  <pre><code class="bash">$ sudo monit status
</code></pre>
  <p>
   To see Monit in action, simply kill the
   <strong>
    webapp
   </strong>
   Node.js process and check the Monit status every couple of seconds.  First, it will fail, then you will see it restart and resume successful connections.  The entire process can take a few minutes.
  </p>
  <h2>
   Grunt
  </h2>
  <p>
   Grunt is a JavaScript Task Runner.  Grunt provides a framework to configure and execute tasks using JavaScript.  Grunt tasks are written as Grunt Plugins, configured with a file named Gruntfile.js, and then executed.
  </p>
  <h3>
   Installation
  </h3>
  <p>
   Grunt is distributed through two Node.js packages with the package ids:
   <strong>
    grunt
   </strong>
   and
   <strong>
    grunt-cli
   </strong>
   .  The
   <strong>
    grunt
   </strong>
   package is installed locally as a development dependency within your Node.js project.  The
   <strong>
    grunt-cli
   </strong>
   package is installed globally.  The local package provides the core grunt functionality.  The global package allows the
   <strong>
    grunt
   </strong>
   command to be executed from a terminal.
  </p>
  <p>
   To install the local, core package, run the following command in a terminal from the main folder of your project.
  </p>
  <pre><code class="bash">$ npm install grunt --save-dev
</code></pre>
  <p>
   To install the global, command line tool package, run the following command in a terminal from any folder on on your computer.  For Mac and Linux computers, you will need to run the command as root.
  </p>
  <pre><code class="bash">$ npm install -g grunt-cli
</code></pre>
  <h3>
   Tasks
  </h3>
  <p>
   To create Grunt tasks, a file named Gruntfile.js must be created in the project folder.  At the top of the file add the following code.
  </p>
  <pre><code class="javascript">module.exports = function (grunt) {
  "use strict";

  // task code will go here...
};
</code></pre>
  <p>
   The grunt parameter refers to the local, core grunt NPM package.
  </p>
  <p>
   The grunt file can be divided into two parts: configuration and tasks.  Configuration is performed using the
   <strong>
    initConfig
   </strong>
   function.
  </p>
  <pre><code class="javascript">grunt.initConfig({
  webServer: {
    port: 8080,
    rootFolder: './www'
  }
});
</code></pre>
  <p>
   The initConfig function expects a JavaScript object that will contain properties that define configuration values for the grunt tasks.
  </p>
  <p>
   To define a task the following
  </p>
  <pre><code class="javascript">grunt.registerTask('default', 'Start a web server', function () {
  // task code
});
</code></pre>
  <p>
   The first parameter to
   <strong>
    registerTask
   </strong>
   is the name of the task.  If the task is the default task, then the name
   <em>
    default
   </em>
   can be used.  The second parameter is a short description of the task.  Finally, the third parameter is a function that defines the task.  The task can do anything the developer would like it to do.
  </p>
  <p>
   To retrieve the configuration information defined with
   <strong>
    initConfig
   </strong>
   the
   <strong>
    config
   </strong>
   function is used.  To retrieve the
   <strong>
    webServer
   </strong>
   configuration defined below the following code is used.
  </p>
  <pre><code class="javascript">var webServerOptions = grunt.config("webServer");

// output 8080 to the console
console.log(webServerOptions.port);

</code></pre>
  <p>
   To run the default task of the grunt file, simply type
   <strong>
    grunt
   </strong>
   on the command line and press enter.
  </p>
  <pre><code class="javascript">grunt.registerTask('webserver', 'Start a web server', function () {
  // task code here...
});
</code></pre>
  <p>
   To execute a named task such as
   <em>
    webserver
   </em>
   listed above, execute the task with the following command.
  </p>
  <pre><code class="bash">$ grunt webserver
</code></pre>
  <p>
   Also, Grunt allows the passing of arguments from the command line into a task. Updating the web server task to accept a port parameters allows the port number to be passed from the command line.  The register task definition would be modified to look like this.
  </p>
  <pre><code class="javascript">grunt.registerTask('webserver', 'Start a web server', function (port) {
  // task code here...
});
</code></pre>
  <p>
   When invoked from the terminal, the Grunt command to run the web server task with a specific port number has the following syntax.
  </p>
  <pre><code class="bash">$ grunt webserver:8080
</code></pre>
  <p>
   Arguments passed in from the command line are colon delimited.  In the case of a string value, the argument syntax is formatted like this.
  </p>
  <pre><code class="bash">$ grunt sometask:"Some Text Here..."
</code></pre>
  <p>
   The string value is wrapped in quotes to allow for spaces in the string value.
  </p>
  <h3>
   Executing An External Program
  </h3>
  <p>
   Within Grunt tasks, a common operation is launch an external program. Here is some sample code demonstrating how to launch external programs.
  </p>
  <pre><code class="javascript">var exec = require('child_process').exec;
var process = exec("ls -al", function(error, stdout, stderr) {
  // do something once the process ends
});
</code></pre>
  <h3>
   Asynchronous Tasks
  </h3>
  <p>
   When running grunt tasks, the task will end even if asynchronous operations are waiting to complete.  The best example would be a web server.  With a typical grunt task, if a web server is started, it will be stopped as soon as the grunt task completes.  This is not desired since the web server needs to continue to run in order to handle requests.  To keep a grunt task running indefinitely, the following function must be called in the grunt task.
  </p>
  <pre><code class="javascript">this.async();
</code></pre>
  <h4>
   Exercise - Setup Grunt Tasks
  </h4>
  <p>
   Step 1. From a terminal, change to the
   <strong>
    myproject
   </strong>
   folder.
  </p>
  <p>
   Step 2. Create a new file named
   <strong>
    Gruntfile.js
   </strong>
   , add the following code to it.  Copy and paste the code from this document being sure to actually review the code to understand what it is doing.
  </p>
  <pre><code class="javascript">module.exports = function (grunt) {
  "use strict";

  grunt.initConfig({
    browserify: {
      js: {
        src: 'app/js/app.js',
        dest: 'dist/js/app.js'
      }
    },
    watch: {
      all: {
        files: ['**/*.html', '**/*.css', '**/*.tpl'],
        tasks: ['copy'],
        options: {
          spawn: false,
          cwd: { files: 'app/' }
        }
      },
      scripts: {
        files: ['**/*.js'],
        tasks: ['browserify','uglify'],
        options: {
          spawn: false,
          cwd: { files: 'app/' }
        }
      },
      angularjs: {
        files: ['node_modules/angular/angular.min.js'],
        tasks: ['copy'],
        options: {
          spawn: false,
          cwd: { files: '/' }
        }
      },
      less: {
        files: ['**/*.less'],
        tasks: ['less','cssmin'],
        options: {
          spawn: false,
          cwd: { files: 'app/' }
        }
      }
    },
    copy: {
      all: {
        expand: true,
        cwd: 'app/',
        src: ['**/*.html', '**/*.css', '**/*.tpl'],
        dest: 'dist/'
      },
      angularjs: {
        expand: true,
        cwd: 'node_modules/angular',
        src: ["angular.min.js"],
        dest: 'dist/js'
      },
      bootstrapcss: {
        expand: true,
        cwd: 'node_modules/bootstrap/dist/css',
        src: ["*"],
        dest: 'dist/css'
      },
      bootstrapfonts: {
        expand: true,
        cwd: 'node_modules/bootstrap/dist/fonts',
        src: ["*"],
        dest: 'dist/fonts'
      }
    },
    less: {
      development: {
        options: {
          paths:["app/less"]
        },
        files: {
          "dist/css/app.css": "app/less/app.less"
        }
      }
    },
    cssmin: {
      minify: {
        expand: true,
        cwd: 'dist/css',
        src: ['*.css', '!*.min.css'],
        dest: 'dist/css',
        ext: '.min.css'
      }
    },
    uglify: {
      my_target: {
        files: {
          'dist/js/app.min.js': ['dist/js/app.js']
        }
      }
    },
    webServer: {
      port: 8080,
      rootFolder: './dist'
    },
    dbSqlLite: {
      file: "lab.db"
    }
  });

  grunt.loadNpmTasks("grunt-browserify");
  grunt.loadNpmTasks("grunt-contrib-copy");
  grunt.loadNpmTasks("grunt-contrib-watch");
  grunt.loadNpmTasks('grunt-contrib-less');
  grunt.loadNpmTasks('grunt-contrib-cssmin');
  grunt.loadNpmTasks('grunt-contrib-uglify');

  grunt.event.on('watch', function(action, filepath, target) {

    grunt.log.writeln(target + ": " + filepath + " has " + action);

  });

  // register a task to run the express server
  grunt.registerTask('webserver', 'Start a web server', function () {

    var
      webServerOptions = grunt.config("webServer"),
      dbSqlLiteOptions = grunt.config("dbSqlLite"),
      webServer = require("./webServer");

      // tells the task this will run async otherwise the task will
      // end the web server when it completes this method
      //this.async();

    webServer(webServerOptions, dbSqlLiteOptions)
      .start()
      .then(function () {
        grunt.log.writeln("Started connect web server on port " + webServerOptions.port);
        grunt.log.writeln("ctrl+c to exit");
      })
      .catch(function (err) {
        grunt.log.error(err.message || err);
      });

  });

  grunt.registerTask('default', ['browserify', 'less', 'cssmin', 'copy', 'uglify', 'webserver', 'watch']);

};
</code></pre>
  <p>
   Save the file, and close it.
  </p>
  <p>
   Step 3. From the terminal, type the command
   <strong>
    grunt
   </strong>
   and press
   <strong>
    enter
   </strong>
   .  This command fire up the default Grunt task.  For this Grunt file, the default Grunt task will launch the web server, configure web sockets, initialize the database, as well as, setup file watchers to execute various development tasks related to packaging modules, compiling preprocessor code and performing file combination and minification.
  </p>
  <p>
   Step 4. What is the difference between the
   <strong>
    app
   </strong>
   folder and the
   <strong>
    dist
   </strong>
   folder?  What is the purpose of each?
  </p>
  <p>
   <strong>
    Exercise Complete!
   </strong>
  </p>
  <h3>
   Grunt Plugins
  </h3>
  <p>
   Grunt plugins allow developers to create generalized tasks that can be reused in many projects.  Typically, Grunt plugins are distributed via NPM and contain logic to perform tasks using the configuration provided by the project that is including the plugin.  Developing Grunt plugins is very simple to do.
  </p>
  <p>
   First, create a folder named after your plugin. In this example, we will use the name
   <strong>
    mygruntplugin
   </strong>
   .
  </p>
  <pre><code class="bash">$ mkdir mygruntplugin
</code></pre>
  <p>
   Change to the folder you created, then create a tasks folder.
  </p>
  <pre><code class="bash">$ cd mygruntplugin

$ mkdir tasks
</code></pre>
  <p>
   Next, create a
   <strong>
    package.json
   </strong>
   file with
   <strong>
    npm init
   </strong>
   , answering the questions as appropriate.
  </p>
  <pre><code class="bash">$ npm init
</code></pre>
  <p>
   At a minimum, add a local
   <strong>
    grunt
   </strong>
   Node.js package to the Grunt plugin package.
  </p>
  <pre><code>$ npm install grunt --save-dev
</code></pre>
  <p>
   Then change to the tasks folder, and create a lib folder.
  </p>
  <pre><code class="bash">$ cd tasks

$ mkdir lib
</code></pre>
  <p>
   The lib folder will contain all of the modules of library code that perform the actual task operations.  The tasks folder is for wiring up the code modules in the lib folder to the named Grunt tasks.  Change to the
   <strong>
    lib
   </strong>
   folder, create a new file named
   <strong>
    mylib.js
   </strong>
   , then add the following code to the file.
  </p>
  <pre><code class="javascript">module.exports = (function() {
  "use strict";

  return function() {
    return {
      log: function(prefix, message) {
        console.log(prefix + "=&gt; " + message);
      }
    };
  };

}());
</code></pre>
  <p>
   This module returns a function object that when invoked returns a custom console logger that allows each log message to prefixed with a message identifier.
  </p>
  <p>
   To wire this code up to a Grunt task, change to the parent tasks folder, create a new file named
   <strong>
    mytask.js
   </strong>
   , then add the following JavaScript code to the file.
  </p>
  <pre><code class="javascript">module.exports = (function() {
  "use strict";

  var myLib = require("./lib/mylib.js");

  return function(grunt) {
    grunt.registerTask("atask", "A sample task", function() {
      myLib().log("MyApp", "sample task");
    });
  };

}());
</code></pre>
  <p>
   This code, wires up the module in the lib folder to a named Grunt task.  The final step to creating the plugin is to create Gruntfile.js for the plugin.  Change to the root package folder, create a file named
   <strong>
    Gruntfile.js
   </strong>
   , then add the following code it.
  </p>
  <pre><code class="javascript">module.exports = (function() {
  "use strict";

  return function(grunt) {
    grunt.loadTasks("tasks");
  };

}());
</code></pre>
  <p>
   The
   <strong>
    Gruntfile.js
   </strong>
   loads the named Grunt tasks from the
   <strong>
    tasks
   </strong>
   folder and makes them available to Grunt in the packages that install this plugin package.
  </p>
  <p>
   To test the Grunt plugin, simply use the NPM package linking (described earlier) to link this package to the project package you are currently working on.  Then include the tasks in this Grunt plugin in the Gruntfile.js of the project package like this.
  </p>
  <pre><code class="javascript">grunt.loadNpmTasks('mygruntplugin');
</code></pre>
  <p>
   Then reference a task from the Grunt plugin as shown here.
  </p>
  <pre><code class="javascript">grunt.registerTask('mytask', 'My Task', ['atask']);
</code></pre>
  <p>
   Save the project package's Grunt file, and run the following from the terminal.
  </p>
  <pre><code class="bash">$ grunt mytask
</code></pre>
  <p>
   The output will be the prefixed console log message that was coded in the Grunt plugin.
  </p>
  <pre><code class="bash">Running "atask" task
MyApp=&gt; sample task

Done, without errors.
</code></pre>
  <p>
   Creating Grunt plugins is very simple and allows for the creation of helpful and sophisticated tasks to be shared among many projects and even publicly distributed.
  </p>
  <p>
   Copyright 2015, Eric W. Greene.  All Rights Reserved.
  </p>
 </body>
</html>
